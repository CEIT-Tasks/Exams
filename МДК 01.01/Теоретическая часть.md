**Перечень теоретических вопросов, выносимых на экзамен по ПМ.11 Разработка, администрирование и защита баз данных**

#### 1. Понятие хранилищ данных, баз знаний
* **Хранилище данных (Data Warehouse)**: Это предметно-ориентированная, интегрированная, неизменяемая и зависящая от времени коллекция данных, предназначенная для поддержки принятия решений. Хранилища данных обычно содержат исторические данные из различных операционных систем.
* **База знаний (Knowledge Base)**: Это особый вид базы данных для управления знаниями. Она хранит структурированную и неструктурированную информацию, такую как правила, факты, процедуры, для использования системами искусственного интеллекта или экспертными системами.

#### 2. Как работают подстановочные знаки в SQL
В SQL подстановочные знаки (wildcard characters) используются с оператором `LIKE` для поиска строк, соответствующих определенному шаблону.
* `%`: Представляет любую последовательность из нуля или более символов. Например, `'А%'` найдет все, что начинается на 'А', а `'Кузн%'` найдет 'Кузнецов', 'Кузнецова', 'Кузница' и т.д.
* `_`: Представляет любой одиночный символ. Например, `'_ол%'` найдет 'Колокол', 'Молоко', но не 'Ол.
* `[charlist]`: Представляет любой одиночный символ из указанного списка. Например, `'[АБВ]%'` найдет все, что начинается на 'А', 'Б' или 'В'.
* `[^charlist]`: Представляет любой одиночный символ, НЕ находящийся в указанном списке.
* `[range]`: Представляет любой одиночный символ в указанном диапазоне. Например, `'[А-Г]%'` найдет все, что начинается на 'А', 'Б', 'В' или 'Г'.

#### 3. Какие типы СУБД в соответствии с моделями данных вы знаете
Основные типы СУБД по моделям данных:
* **Реляционные СУБД (РСУБД)**: Основаны на реляционной модели данных, где данные организованы в таблицы (отношения). Примеры: Microsoft SQL Server, MySQL, PostgreSQL, Oracle.
* **Иерархические СУБД**: Данные организованы в древовидную структуру, где каждый "родитель" может иметь несколько "потомков", но каждый "потомок" имеет только одного "родителя". Используются редко в новых разработках.
* **Сетевые СУБД**: Расширение иерархической модели, позволяющее "потомку" иметь несколько "родителей", образуя сетевую структуру. Также редко используются сейчас.
* **Объектно-ориентированные СУБД (ООСУБД)**: Хранят данные в виде объектов, похожих на объекты в объектно-ориентированных языках программирования.
* **NoSQL СУБД**: Широкая категория баз данных, которые не используют традиционную реляционную модель. Они разработаны для работы с большими объемами распределенных данных и включают:
    * **Документоориентированные СУБД**: Хранят данные в виде полуструктурированных документов (например, JSON, XML). Примеры: MongoDB, Couchbase.
    * **Ключ-значение СУБД**: Хранят данные в виде пар ключ-значение. Примеры: Redis, DynamoDB.
    * **Колоночные СУБД**: Хранят данные по столбцам, а не по строкам, что оптимизировано для агрегатных запросов. Примеры: Cassandra, HBase.
    * **Графовые СУБД**: Хранят данные в виде графа, состоящего из узлов (сущностей) и ребер (связей). Примеры: Neo4j, ArangoDB.

#### 4. Что такое первичный ключ
**Первичный ключ (Primary Key)** - это одно или несколько полей (столбцов) в таблице, которые уникально идентифицируют каждую запись (строку) в этой таблице. Основные характеристики первичного ключа:
* **Уникальность**: Каждое значение первичного ключа должно быть уникальным в таблице.
* **Неизменность**: Значение первичного ключа не должно изменяться.
* **NotNull (Непустое)**: Первичный ключ не может содержать NULL значения.
* В одной таблице может быть только один первичный ключ.
Первичный ключ обеспечивает целостность сущностей.

#### 5. Что такое внешний ключ
**Внешний ключ (Foreign Key)** - это одно или несколько полей в таблице (таблице-потомке), которые ссылаются на первичный ключ в другой таблице (таблице-родителе). Внешний ключ устанавливает связь между двумя таблицами, обеспечивая ссылочную целостность данных.
* Значение внешнего ключа в таблице-потомке либо должно быть NULL, либо должно совпадать с каким-либо значением первичного ключа в таблице-родителе.
* Внешние ключи предотвращают создание "висячих" записей, когда запись ссылается на несуществующую запись в другой таблице.

#### 6. Основные принципы построения концептуальной модели данных
**Концептуальная модель данных** - это высокоуровневое, независимое от СУБД представление данных, которое описывает сущности, их атрибуты и связи между ними с точки зрения пользователя или предметной области. Основные принципы:
* **Независимость от реализации**: Не зависит от конкретной СУБД или технологии.
* **Фокус на предметной области**: Сосредоточена на том, какие данные важны для бизнеса и как они взаимосвязаны.
* **Использование сущностей, атрибутов и связей**:
    * **Сущность (Entity)**: Объект или концепция, о которой необходимо хранить данные (например, "Продукт", "Заказ").
    * **Атрибут (Attribute)**: Характеристика сущности (например, "Название продукта", "Дата заказа").
    * **Связь (Relationship)**: Ассоциация между двумя или более сущностями (например, "Клиент делает Заказ").
* **Устранение избыточности**: Цель - минимизировать дублирование данных.
* **Понятность для конечных пользователей**: Модель должна быть легко понятна бизнес-пользователям, не являющимся техническими специалистами.

#### 7. Основные принципы построения логической модели данных
**Логическая модель данных** - это более детализированное представление данных, чем концептуальная модель, но все еще независимое от конкретной СУБД. Она описывает данные в терминах таблиц, столбцов, первичных и внешних ключей, а также их взаимосвязей. Основные принципы:
* **Трансляция сущностей в таблицы**: Каждая сущность из концептуальной модели становится таблицей.
* **Трансляция атрибутов в столбцы**: Каждый атрибут сущности становится столбцом в соответствующей таблице.
* **Определение первичных ключей**: Для каждой таблицы определяется уникальный первичный ключ.
* **Определение внешних ключей**: Для представления связей между таблицами используются внешние ключи.
* **Нормализация данных**: Приведение таблиц к нормальным формам (1NF, 2NF, 3NF и т.д.) для устранения избыточности и аномалий обновления.
* **Определение типов данных**: Уточнение типов данных для каждого столбца (например, строковый, числовой, дата).
* **Учет ограничений (Constraints)**: Определение правил целостности данных, таких как NOT NULL, UNIQUE.

#### 8. Основные принципы построения физической модели данных
**Физическая модель данных** - это наиболее детализированное представление данных, которое учитывает специфику конкретной СУБД и физическое хранение данных. Она описывает, как данные будут фактически реализованы и храниться в базе данных. Основные принципы:
* **Зависимость от СУБД**: Модель специфична для конкретной СУБД (например, SQL Server, Oracle).
* **Определение конкретных типов данных**: Выбор конкретных типов данных, поддерживаемых выбранной СУБД (например, `INT`, `VARCHAR(255)`, `DATETIME`).
* **Создание индексов**: Определение индексов для улучшения производительности запросов.
* **Размещение данных на диске**: Планирование того, как данные будут храниться на физических носителях (например, файловые группы, таблицы в памяти).
* **Определение партиционирования**: Разделение больших таблиц на более мелкие, управляемые части.
* **Определение представлений (Views)**: Создание виртуальных таблиц для упрощения доступа к данным и обеспечения безопасности.
* **Определение хранимых процедур, функций, триггеров**: Разработка объектов для реализации бизнес-логики и автоматизации операций.
* **Настройка параметров производительности**: Оптимизация параметров СУБД для обеспечения лучшей производительности.

#### 9. Основные принципы структуризации и нормализации базы данных.
**Структуризация базы данных** - это процесс организации данных таким образом, чтобы они были легко доступны, управляемы и эффективны для хранения и извлечения. Основные принципы:
* **Разделение на таблицы**: Данные должны быть логически разделены на отдельные таблицы, каждая из которых представляет собой определенную сущность.
* **Уникальная идентификация**: Каждая запись в таблице должна иметь уникальный идентификатор (первичный ключ).
* **Связи между таблицами**: Установление связей между таблицами с помощью внешних ключей.
* **Целостность данных**: Обеспечение точности и непротиворечивости данных.

**Нормализация базы данных** - это систематический процесс реорганизации реляционной базы данных для снижения избыточности данных и улучшения целостности данных. Это достигается путем разделения больших таблиц на более мелкие и связанные таблицы. Основные нормальные формы:
* **Первая нормальная форма (1NF)**:
    * Каждый столбец должен содержать атомарные (неделимые) значения.
    * Каждая запись должна быть уникальной.
    * Каждый столбец должен иметь уникальное имя.
* **Вторая нормальная форма (2NF)**:
    * Находится в 1NF.
    * Все неключевые атрибуты должны полностью зависеть от *всего* первичного ключа (для таблиц с составным ключом). Отсутствие частичных функциональных зависимостей.
* **Третья нормальная форма (3NF)**:
    * Находится во 2NF.
    * Отсутствие транзитивных функциональных зависимостей: неключевые атрибуты не должны зависеть от других неключевых атрибутов.
* **Бойса-Кодда нормальная форма (BCNF)**: Более строгая версия 3NF.
* **Четвертая нормальная форма (4NF)**: Устранение многозначных зависимостей.
* **Пятая нормальная форма (5NF)**: Устранение зависимостей соединения.
Цель нормализации - минимизировать дублирование данных, избежать аномалий вставки, удаления и обновления, а также улучшить целостность данных.

#### 10. Методы организации целостности данных
Целостность данных относится к обеспечению точности и непротиворечивости данных в базе данных. Основные методы организации целостности данных включают:
* **Целостность сущностей (Entity Integrity)**: Обеспечивается первичными ключами. Гарантирует, что каждая запись в таблице уникальна и имеет непустое значение первичного ключа.
* **Ссылочная целостность (Referential Integrity)**: Обеспечивается внешними ключами. Гарантирует, что связи между таблицами поддерживаются, и ссылки на несуществующие записи предотвращаются. Примеры правил для ссылочной целостности:
    * `ON DELETE CASCADE`: Удаление записи в родительской таблице приводит к удалению связанных записей в дочерней таблице.
    * `ON DELETE SET NULL`: Удаление записи в родительской таблице устанавливает NULL для соответствующих внешних ключей в дочерней таблице.
    * `ON DELETE NO ACTION` / `RESTRICT`: Предотвращает удаление родительской записи, если существуют зависимые дочерние записи.
* **Доменная целостность (Domain Integrity)**: Определяет допустимый набор значений для столбца. Обеспечивается через:
    * **Типы данных**: Ограничение типа значений, которые могут храниться в столбце (например, `INT`, `VARCHAR`, `DATE`).
    * **Ограничения CHECK (CHECK Constraints)**: Пользовательские правила, ограничивающие допустимые значения в столбце (например, `CHECK (Возраст >= 18)`).
    * **Ограничения NOT NULL**: Гарантирует, что столбец не может содержать NULL значения.
* **Пользовательская целостность (User-Defined Integrity)**: Правила, которые не могут быть реализованы с помощью стандартных ограничений целостности, и требуют реализации через:
    * **Триггеры (Triggers)**: Специальные хранимые процедуры, которые автоматически выполняются при определенных событиях (вставка, обновление, удаление) в таблице.
    * **Хранимые процедуры (Stored Procedures)**: Пользовательские процедуры, которые инкапсулируют бизнес-логику и могут содержать проверки целостности.
    * **Транзакции (Transactions)**: Группировка нескольких операций в одну логическую единицу работы, которая либо полностью выполняется, либо полностью отменяется, обеспечивая атомарность и согласованность.

#### 11. Способы контроля доступа к данным
Контроль доступа к данным (Access Control) - это процесс определения, какие пользователи или группы пользователей имеют право выполнять те или иные операции с данными. Основные способы включают:
* **Аутентификация (Authentication)**: Процесс проверки личности пользователя. Включает:
    * **Имя пользователя и пароль**: Самый распространенный метод.
    * **Многофакторная аутентификация (MFA)**: Использование нескольких факторов для подтверждения личности.
    * **Windows Authentication (в SQL Server)**: Использование учетных записей Windows для аутентификации в СУБД.
    * **SQL Server Authentication**: Использование логинов и паролей, управляемых непосредственно SQL Server.
* **Авторизация (Authorization)**: Процесс предоставления или отзыва разрешений (привилегий) на выполнение операций с объектами базы данных после успешной аутентификации.
* **Модель дискреционного контроля доступа (DAC - Discretionary Access Control)**: Владелец объекта или пользователь, которому предоставлены соответствующие разрешения, может предоставить или отозвать разрешения для других пользователей.
* **Модель обязательного контроля доступа (MAC - Mandatory Access Control)**: Правила доступа определяются централизованно администратором безопасности на основе классификации данных и уровней допуска пользователей.
* **Контроль доступа на основе ролей (RBAC - Role-Based Access Control)**: Пользователи назначаются на роли, а роли имеют определенные разрешения. Это упрощает управление разрешениями, особенно в больших системах.
* **Контроль доступа на основе атрибутов (ABAC - Attribute-Based Access Control)**: Решения о доступе принимаются на основе атрибутов пользователя, ресурса и среды.

#### 12. Способы управления привилегиями
Управление привилегиями в СУБД - это процесс предоставления и отзыва разрешений (прав) для пользователей или ролей на выполнение операций с объектами базы данных.
* **Операторы GRANT и REVOKE**:
    * `GRANT`: Используется для предоставления разрешений. Например, `GRANT SELECT, UPDATE ON ТаблицаНазвание TO ПользовательНазвание;`
    * `REVOKE`: Используется для отзыва ранее предоставленных разрешений. Например, `REVOKE DELETE ON ТаблицаНазвание FROM ПользовательНазвание;`
* **Разрешения на уровне сервера**: Предоставляют права на операции на уровне экземпляра SQL Server (например, создание баз данных, управление безопасностью).
* **Разрешения на уровне базы данных**: Предоставляют права на операции в конкретной базе данных (например, создание таблиц, хранимых процедур).
* **Разрешения на уровне объектов**: Предоставляют права на конкретные объекты базы данных (таблицы, представления, хранимые процедуры, функции и т.д.). Общие разрешения включают `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `EXECUTE`, `ALTER`, `CONTROL`.
* **Роли (Roles)**: Группы разрешений. Пользователи назначаются на роли, что упрощает управление разрешениями. В SQL Server существуют:
    * **Фиксированные серверные роли (Fixed Server Roles)**: Предопределенные роли с определенными разрешениями на уровне сервера (например, `sysadmin`, `securityadmin`).
    * **Фиксированные роли базы данных (Fixed Database Roles)**: Предопределенные роли с определенными разрешениями на уровне базы данных (например, `db_owner`, `db_datareader`).
    * **Пользовательские роли (User-Defined Roles)**: Роли, создаваемые администратором для группировки пользовательских разрешений.
* **Принцип наименьших привилегий (Principle of Least Privilege)**: Предоставление пользователям только тех минимально необходимых прав, которые требуются для выполнения их задач.

#### 13. Реляционное исчисление
**Реляционное исчисление (Relational Calculus)** - это декларативный язык запросов для реляционных баз данных, который описывает, *что* нужно извлечь из базы данных, а не *как* это сделать (в отличие от реляционной алгебры, которая является процедурной). Существует два основных типа реляционного исчисления:
* **Кортежное реляционное исчисление (Tuple Relational Calculus - TRC)**: Использует переменные, которые представляют кортежи (строки) в отношениях. Запросы формулируются как предикаты, которые должны быть истинными для кортежей, которые должны быть включены в результат. Пример: "Найти все кортежи `t` такие, что `t` находится в отношении `R` И `t.A > 10`".
* **Доменное реляционное исчисление (Domain Relational Calculus - DRC)**: Использует переменные, которые представляют значения доменов (отдельные атрибуты/столбцы). Запросы формулируются путем указания доменных переменных и условий, которым эти значения должны удовлетворять. Пример: "Найти `A, B` такие, что существует кортеж в `R` с атрибутами `A, B` И `A > 10`".
Оба типа исчисления эквивалентны по выразительной силе реляционной алгебре и SQL. Они предоставляют теоретическую основу для проектирования языков запросов.

#### 14. Компоненты и структуры данных
В контексте СУБД, "компоненты" обычно относятся к основным частям системы управления базами данных, а "структуры данных" - к тому, как данные организованы и хранятся внутри этих компонентов.
**Компоненты СУБД**:
* **Ядро СУБД (Database Engine)**: Основной компонент, отвечающий за хранение, извлечение, обновление и удаление данных. Включает:
    * **Подсистема хранения (Storage Engine)**: Управляет физическим хранением данных на диске.
    * **Процессор запросов (Query Processor)**: Анализирует, оптимизирует и выполняет SQL-запросы.
    * **Диспетчер транзакций (Transaction Manager)**: Обеспечивает атомарность, согласованность, изоляцию и долговечность транзакций (ACID).
    * **Диспетчер блокировок (Lock Manager)**: Управляет блокировками для обеспечения параллельного доступа к данным.
    * **Менеджер буфера (Buffer Manager)**: Управляет кэшированием данных в оперативной памяти.
* **Система управления доступом к данным (Data Access Management System)**: Отвечает за безопасность, аутентификацию и авторизацию.
* **Система резервного копирования и восстановления (Backup and Recovery System)**: Обеспечивает возможность восстановления данных после сбоев.
* **Мониторинг и управление (Monitoring and Management Tools)**: Инструменты для отслеживания производительности, конфигурации и администрирования СУБД.
* **API/Интерфейсы**: Программные интерфейсы для взаимодействия приложений с базой данных (например, ODBC, JDBC, ADO.NET).

**Структуры данных в СУБД**:
* **Таблицы (Tables)**: Основные структуры для хранения данных в реляционной модели, состоящие из строк (записей) и столбцов (атрибутов).
* **Индексы (Indexes)**: Структуры данных, которые улучшают скорость поиска данных в таблицах. Обычно реализуются как B-деревья или хеш-таблицы. 
* **Представления (Views)**: Виртуальные таблицы, основанные на результате SQL-запроса. Не хранят данные, но представляют их в определенном виде. 
* **Кластеры (Clusters)**: Метод физического хранения данных, при котором записи из разных таблиц, часто используемые вместе, хранятся на диске рядом для ускорения доступа. 
* **Хранимые процедуры (Stored Procedures)**: Предварительно скомпилированный набор инструкций SQL, хранящийся в базе данных. 
* **Триггеры (Triggers)**: Специальные хранимые процедуры, которые автоматически выполняются при определенных событиях (вставка, обновление, удаление) в таблице. 
* **Журнал транзакций (Transaction Log)**: Файл, который записывает все изменения, внесенные в базу данных, что критично для восстановления и обеспечения целостности транзакций.

#### 15. Методы описания схем баз данных в современных СУБД
Схема базы данных описывает структуру базы данных. Методы описания включают:
* **Язык определения данных (DDL - Data Definition Language)**: Часть SQL, используемая для создания, изменения и удаления объектов базы данных. Примеры команд:
    * `CREATE TABLE`: Создание таблицы.
    * `ALTER TABLE`: Изменение структуры таблицы.
    * `DROP TABLE`: Удаление таблицы.
    * `CREATE INDEX`: Создание индекса.
    * `CREATE VIEW`: Создание представления.
    * `CREATE PROCEDURE`: Создание хранимой процедуры.
* **Диаграммы "Сущность-Связь" (ERD - Entity-Relationship Diagrams)**: Графическое представление концептуальной модели данных, показывающее сущности, их атрибуты и связи.
* **XML Schema Definition (XSD)**: Используется для описания структуры XML-документов, которые могут представлять данные или схемы данных.
* **JSON Schema**: Используется для описания структуры JSON-документов.
* **CASE-средства (Computer-Aided Software Engineering)**: Программные инструменты, которые помогают в проектировании, разработке и управлении базами данных, включая создание ERD и генерацию DDL-скриптов (например, ER/Studio, PowerDesigner).
* **Системные каталоги/Словари данных (System Catalogs/Data Dictionary)**: Внутри СУБД хранится метаданные (данные о данных), описывающие структуру всех объектов базы данных. К ним можно получить доступ через системные представления или функции.

#### 16. Структуры данных СУБД
См. ответ на вопрос 14, пункт "Структуры данных в СУБД". Основные структуры данных включают:
* **Таблицы**
* **Индексы**
* **Представления**
* **Кластеры**
* **Журнал транзакций**
Эти структуры используются СУБД для эффективного хранения, организации и доступа к данным.

#### 17. Общий подход к организации представлений, таблиц, индексов и кластеров
* **Таблицы (Tables)**: Являются фундаментальными объектами хранения данных. Каждая таблица представляет собой логическую сущность и состоит из строк и столбцов. При организации таблиц важно следовать принципам нормализации для минимизации избыточности и обеспечения целостности данных.
* **Представления (Views)**: Виртуальные таблицы, созданные на основе запроса к одной или нескольким базовым таблицам. Представления используются для:
    * **Упрощения запросов**: Сложные соединения или выборки могут быть инкапсулированы в представление.
    * **Обеспечения безопасности**: Можно предоставить пользователям доступ к определенным столбцам или строкам таблицы, не раскрывая всю таблицу.
    * **Представления данных в различных форматах**: Одна и та же базовая таблица может быть представлена по-разному для разных пользователей или приложений.
* **Индексы (Indexes)**: Специальные структуры данных, которые создаются для ускорения операций поиска и сортировки данных в таблицах. Они работают аналогично предметному указателю в книге, позволяя СУБД быстро находить нужные строки без полного сканирования таблицы.
    * **Кластеризованные индексы (Clustered Indexes)**: Определяют физический порядок хранения строк данных в таблице. Таблица может иметь только один кластеризованный индекс.
    * **Некластеризованные индексы (Non-Clustered Indexes)**: Отдельные структуры, которые содержат указатели на строки данных. Таблица может иметь множество некластеризованных индексов.
* **Кластеры (Clusters)**: В некоторых СУБД (например, Oracle) кластеры - это способ физического хранения данных из нескольких таблиц вместе на диске, если они часто запрашиваются совместно. Это улучшает производительность операций соединения. В SQL Server понятие кластера в основном относится к кластеризованным индексам, где данные строк физически упорядочены на основе значений ключа индекса.

#### 18. Способы контроля доступа к данным
См. ответ на вопрос 11.

#### 19. Управление привилегиями
См. ответ на вопрос 12.

#### 20. Алгоритм проведения процедуры резервного копирования
Алгоритм проведения процедуры резервного копирования в Microsoft SQL Server обычно включает следующие шаги:
1.  **Определение стратегии резервного копирования**:
    * **Полное резервное копирование (Full Backup)**: Копирует всю базу данных.
    * **Разностное резервное копирование (Differential Backup)**: Копирует только те данные, которые изменились с момента последнего *полного* резервного копирования.
    * **Резервное копирование журнала транзакций (Transaction Log Backup)**: Копирует записи из журнала транзакций, что позволяет восстанавливать базу данных до определенного момента времени.
2.  **Выбор места хранения резервных копий**: Определить, где будут храниться файлы резервных копий (локальный диск, сетевая папка, облачное хранилище).
3.  **Определение частоты резервного копирования**: Зависит от требований к восстановлению (Recovery Point Objective - RPO) и частоты изменений данных.
4.  **Планирование заданий резервного копирования**: Использование SQL Server Agent для автоматического выполнения резервного копирования по расписанию.
5.  **Выполнение команды BACKUP DATABASE**:
    ```sql
    BACKUP DATABASE [YourDatabaseName] TO DISK = N'C:\Backup\YourDatabaseName_Full.bak' WITH NOFORMAT, NOINIT, NAME = N'YourDatabaseName-Full Database Backup', SKIP, NOREWIND, NOUNLOAD, STATS = 10;
    ```
	* `TO DISK`: Указывает путь к файлу резервной копии.
    * `WITH FORMAT` / `NOFORMAT`: Перезаписывать ли существующие наборы резервных копий.
    * `WITH INIT` / `NOINIT`: Инициализировать ли медиа-набор.
    * `WITH NAME`: Имя набора резервных копий.
    * `WITH STATS`: Отображение прогресса.
6.  **Мониторинг процесса резервного копирования**: Проверка успешности выполнения заданий, отслеживание ошибок.
7.  **Проверка целостности резервных копий**: Регулярное тестирование резервных копий путем их восстановления на тестовом сервере для убедительности в их пригодности.
8.  **Документирование**: Ведение журнала всех резервных копий и процедур.

#### 21. Модели восстановления SQL-сервера
Модели восстановления (Recovery Models) в SQL Server определяют, как управляется журнал транзакций и как база данных может быть восстановлена. Выбор модели восстановления влияет на возможности восстановления и размер журнала транзакций.
* **Простая модель восстановления (Simple Recovery Model)**:
    * Журнал транзакций автоматически усекается (освобождается место) после контрольной точки (checkpoint) или резервного копирования журнала (но резервное копирование журнала не является обязательным).
    * Не позволяет восстановить базу данных до определенного момента времени (Point-in-Time Recovery).
    * Подходит для баз данных, где допустима небольшая потеря данных, или для тестовых/разработочных баз данных.
    * Можно выполнять только полные и разностные резервные копии.
* **Полная модель восстановления (Full Recovery Model)**:
    * Все операции записываются в журнал транзакций. Журнал усекается только после резервного копирования журнала транзакций.
    * Позволяет восстановить базу данных до любого момента времени, при условии наличия полных, разностных и всех последующих резервных копий журнала транзакций.
    * Требует регулярного резервного копирования журнала транзакций.
    * Подходит для критически важных баз данных, где недопустима потеря данных.
* **Модель восстановления с массовым протоколированием (Bulk-Logged Recovery Model)**:
    * Компромисс между простой и полной моделями.
    * Большинство операций регистрируются полностью, но некоторые операции с большими объемами данных (например, `BULK INSERT`, `SELECT INTO`, `CREATE INDEX`) регистрируются минимально, что снижает размер журнала транзакций.
    * Позволяет восстановить базу данных до момента времени, предшествующего операции с минимальным протоколированием, или до конца любой резервной копии. Не позволяет выполнить точечное восстановление во время или сразу после операции с минимальным протоколированием.
    * Требует регулярного резервного копирования журнала транзакций.
    * Подходит для ситуаций, где есть большие массовые операции, и допустимо небольшое снижение точности восстановления в эти периоды.

#### 22. Резервное копирование баз данных
Резервное копирование баз данных - это процесс создания копии данных для защиты от потери данных, вызванной сбоями оборудования, программного обеспечения, человеческими ошибками, стихийными бедствиями или злонамеренными атаками.
Типы резервных копий в SQL Server:
* **Полное резервное копирование (Full Backup)**: Содержит всю базу данных, включая часть журнала транзакций, необходимую для восстановления до момента завершения резервного копирования. Это основа для всех других типов резервных копий.
* **Разностное резервное копирование (Differential Backup)**: Содержит только те изменения, которые произошли с момента последнего полного резервного копирования. Разностные копии меньше полных и быстрее создаются, но для восстановления требуется и полная, и разностная копия.
* **Резервное копирование журнала транзакций (Transaction Log Backup)**: Копирует активную часть журнала транзакций. Эти резервные копии позволяют выполнять точечное восстановление и являются основой для непрерывной защиты данных в полной и bulk-logged моделях восстановления.
* **Файловое резервное копирование (File Backup)**: Позволяет создавать резервные копии отдельных файлов или файловых групп базы данных. Полезно для очень больших баз данных.
* **Частичное резервное копирование (Partial Backup)**: Для баз данных, содержащих файловые группы только для чтения. Копирует только файловые группы только для чтения.

#### 23. Восстановление баз данных
Восстановление баз данных - это процесс возвращения базы данных в согласованное состояние после сбоя или потери данных, используя ранее созданные резервные копии.
Основные шаги процесса восстановления:
1.  **Определение точки восстановления**: До какого момента времени необходимо восстановить данные (например, до последнего полного бэкапа, до последнего бэкапа журнала транзакций, до конкретного момента времени).
2.  **Выполнение команды RESTORE DATABASE**:
    * **RESTORE DATABASE FROM DISK = ... WITH NORECOVERY**: Используется для восстановления полного бэкапа (и/или разностного) и оставляет базу данных в состоянии "восстановления" (NORECOVERY), чтобы можно было применить последующие резервные копии журнала транзакций.
    * **RESTORE LOG FROM DISK = ... WITH NORECOVERY**: Используется для применения резервных копий журнала транзакций.
    * **RESTORE DATABASE ... WITH RECOVERY**: Окончательное восстановление, которое переводит базу данных в рабочее состояние.
    * **RESTORE DATABASE ... WITH STANDBY = 'undo_file_path'**: Используется для восстановления базы данных в режим ожидания (read-only), что позволяет использовать ее для отчетов, пока она готова к применению новых логов (для логического резервирования).
3.  **Применение резервных копий в правильном порядке**: Полная -> Разностная (если есть) -> Журнал транзакций (в хронологическом порядке).
4.  **Точечное восстановление (Point-in-Time Recovery)**: При полной модели восстановления можно восстановить базу данных до определенной даты и времени, используя опции `WITH STOPAT = 'datetime'` или `WITH STOPATMARK = 'mark_name'`.
5.  **Мониторинг процесса восстановления**: Отслеживание сообщений об ошибках.
6.  **Проверка восстановленной базы данных**: Убедиться, что данные целостны и доступны.

#### 24. Аутентификация пользователей в СУБД
**Аутентификация** - это процесс проверки личности пользователя, который пытается подключиться к СУБД. В Microsoft SQL Server существует два основных режима аутентификации:
* **Аутентификация Windows (Windows Authentication)**:
    * SQL Server использует механизм аутентификации операционной системы Windows для проверки учетных данных пользователя.
    * Пользователи подключаются к SQL Server с использованием своих учетных записей домена или локальных учетных записей Windows.
    * Это рекомендуемый метод аутентификации, так как он обеспечивает централизованное управление пользователями, использует надежные протоколы безопасности Windows (Kerberos) и поддерживает функции, такие как групповые политики.
    * Поддерживает Single Sign-On (SSO).
* **Аутентификация SQL Server (SQL Server Authentication)**:
    * SQL Server управляет собственными именами входа (логинами) и паролями.
    * Пользователи создают отдельные имена входа и пароли непосредственно в SQL Server.
    * Пароли хранятся в SQL Server.
    * Может быть использована, когда пользователи не находятся в домене Windows или когда требуется более гранулярный контроль над аутентификацией внутри SQL Server.
    * Менее безопасна, чем аутентификация Windows, так как требует отдельного управления паролями и не использует преимуществ доменной безопасности.
* **Смешанный режим (Mixed Mode Authentication)**: Позволяет использовать как аутентификацию Windows, так и аутентификацию SQL Server. Это часто используется для обеспечения гибкости.

#### 25. Назначение серверных ролей и ролей баз данных
**Серверные роли (Server Roles)** и **Роли баз данных (Database Roles)** используются для управления разрешениями и упрощения администрирования безопасности в SQL Server. Они позволяют группировать пользователей и логины и назначать им права доступа к ресурсам на соответствующем уровне.

* **Серверные роли (Server Roles)**:
    * **Назначение**: Предоставляют разрешения на уровне экземпляра SQL Server. Это разрешения, которые влияют на всю работу SQL Server, а не на конкретную базу данных.
    * **Примеры фиксированных серверных ролей**:
        * `sysadmin`: Имеет полный контроль над экземпляром SQL Server.
        * `securityadmin`: Управляет логинами и их свойствами.
        * `serveradmin`: Управляет конфигурацией сервера.
        * `setupadmin`: Может добавлять и удалять связанные серверы, управлять процедурами запуска.
        * `processadmin`: Может завершать процессы SQL Server.
        * `diskadmin`: Управляет файлами данных дисков.
        * `dbcreator`: Может создавать, изменять и удалять базы данных.
        * `bulkadmin`: Может выполнять операции `BULK INSERT`.
    * **Пользовательские серверные роли**: В более поздних версиях SQL Server можно создавать пользовательские серверные роли для более гранулированного управления разрешениями на уровне сервера.

* **Роли баз данных (Database Roles)**:
    * **Назначение**: Предоставляют разрешения на уровне конкретной базы данных. Эти разрешения применяются только в пределах той базы данных, в которой определена роль.
    * **Примеры фиксированных ролей баз данных**:
        * `db_owner`: Имеет полный административный контроль над базой данных.
        * `db_datareader`: Может считывать все данные из всех пользовательских таблиц и представлений.
        * `db_datawriter`: Может добавлять, удалять или изменять данные во всех пользовательских таблицах.
        * `db_denydatareader`: Запрещает пользователям чтение данных из базы данных.
        * `db_denydatawriter`: Запрещает пользователям запись данных в базу данных.
        * `db_ddladmin`: Может выполнять любые команды DDL (Data Definition Language) в базе данных.
        * `db_securityadmin`: Может управлять разрешениями, ролями и владениями в базе данных.
        * `db_accessadmin`: Может управлять доступом пользователей к базе данных.
    * **Пользовательские роли баз данных**: Могут быть созданы для определения специфических наборов разрешений, необходимых для выполнения определенных задач в базе данных. Это позволяет применять принцип наименьших привилегий.

#### 26. Авторизация пользователей при получении доступа к ресурсам
**Авторизация** - это процесс определения, какие действия может выполнять аутентифицированный пользователь после успешного подключения к СУБД. Это достигается путем предоставления или отзыва разрешений на конкретные объекты или операции.
В SQL Server авторизация реализуется через:
* **Имена входа (Logins)**: Представляют пользователей на уровне сервера и могут иметь разрешения на уровне сервера или быть сопоставлены с пользователями базы данных.
* **Пользователи базы данных (Database Users)**: Представляют пользователей внутри конкретной базы данных и могут иметь разрешения на уровне базы данных или объекта.
* **Схемы (Schemas)**: Логические контейнеры для объектов базы данных (таблиц, представлений, хранимых процедур). Разрешения могут быть предоставлены на уровне схемы, что упрощает управление.
* **Разрешения (Permissions)**: Специфические права на выполнение определенных действий. Разрешения могут быть:
    * **Явные (Explicit)**: Предоставляются непосредственно пользователю или роли.
    * **Неявные (Implicit)**: Наследуются от членства в ролях.
    * **Отзыв (REVOKE)**: Удаляет ранее предоставленное разрешение.
    * **Запрет (DENY)**: Явно запрещает выполнение операции, даже если пользователь имеет это разрешение через членство в другой роли. `DENY` имеет приоритет над `GRANT`.
* **Цепочки владения (Ownership Chaining)**: Если объект (например, хранимая процедура) ссылается на другой объект (например, таблицу), и оба объекта принадлежат одному и тому же владельцу, то пользователю достаточно иметь разрешение на выполнение хранимой процедуры, и ему не нужно иметь отдельные разрешения на базовую таблицу. Это упрощает управление безопасностью и повышает ее эффективность.

#### 27. Домены в СУБД
В контексте реляционных баз данных, **домен** - это именованный набор допустимых значений, которые может принимать атрибут (столбец) в таблице. По сути, это определяет тип данных и допустимые ограничения для столбца.
Примеры доменов:
* **Числовые домены**: Целые числа, десятичные числа, числа с плавающей запятой, с ограничениями по диапазону или точности.
* **Строковые домены**: Текстовые данные, ограниченные по длине, с определенным набором допустимых символов или шаблонов.
* **Даты и время**: Домены для хранения даты, времени или их комбинации.
* **Булевы домены**: Истина/Ложь, 0/1.
* **Перечисляемые домены**: Набор предопределенных значений (например, 'Мужской', 'Женский').
Цель доменов - обеспечение **доменной целостности**, которая гарантирует, что каждое значение в столбце соответствует его определенному домену. В SQL Server домены напрямую не определяются как отдельные объекты (как в некоторых других СУБД), но концепция реализуется через:
* **Типы данных (Data Types)**: `INT`, `VARCHAR`, `DATETIME`, `DECIMAL` и т.д.
* **Ограничения CHECK (CHECK Constraints)**: Позволяют определить правила для допустимых значений в столбце (например, `CHECK (Возраст >= 0 AND Возраст <= 150)`).
* **Правила (Rules - устаревшая функция)**: Ранее использовались для привязки правил к столбцам или пользовательским типам данных.
* **Пользовательские типы данных (User-Defined Data Types - UDT)**: Позволяют создавать новые типы данных на основе существующих системных типов.

#### 28. Триггеры: понятие, назначение, синтаксис
**Триггер (Trigger)** - это специальный тип хранимой процедуры, которая автоматически выполняется (запускается) при возникновении определенного события в базе данных. Эти события обычно связаны с операциями модификации данных: `INSERT`, `UPDATE`, `DELETE`.
* **Назначение**:
    * **Поддержание целостности данных**: Реализация сложной бизнес-логики и правил целостности, которые не могут быть обеспечены стандартными ограничениями (CHECK, FOREIGN KEY). Например, проверка сложных взаимосвязей между таблицами или автоматическое обновление данных в других таблицах.
    * **Аудит данных**: Запись изменений данных в журнал аудита.
    * **Автоматизация задач**: Автоматическое выполнение действий в ответ на изменения данных (например, отправка уведомлений, вычисление агрегатов).
    * **Синхронизация данных**: Поддержание согласованности данных между несколькими таблицами.
* **Типы триггеров в SQL Server**:
    * **DML-триггеры (Data Manipulation Language)**: Запускаются в ответ на `INSERT`, `UPDATE` или `DELETE` операции.
        * `AFTER` триггеры: Запускаются после завершения DML-операции.
        * `INSTEAD OF` триггеры: Заменяют стандартную DML-операцию и могут быть использованы для обработки операций на представлениях.
    * **DDL-триггеры (Data Definition Language)**: Запускаются в ответ на DDL-события (например, `CREATE TABLE`, `ALTER INDEX`, `DROP DATABASE`).
    * **Logon-триггеры**: Запускаются при установлении соединения с SQL Server.
* **Синтаксис (пример DML триггера `AFTER INSERT`)**:
    ```sql
    CREATE TRIGGER TR_ProductName_Audit
    ON Products
    AFTER INSERT, UPDATE
    AS
    BEGIN
        -- Вставляем данные в таблицу аудита после INSERT или UPDATE
        INSERT INTO ProductAudit (ProductID, OldName, NewName, ChangeDate)
        SELECT
            i.ID,
            d.Name, -- Для UPDATE - старое имя, для INSERT - NULL
            i.Name,
            GETDATE()
        FROM
            inserted i
        LEFT JOIN
            deleted d ON i.ID = d.ID; -- d содержит старые значения для UPDATE
    END;
    ```
    * `inserted` и `deleted`: Специальные логические таблицы, доступные внутри триггеров. `inserted` содержит новые строки (для INSERT и UPDATE), `deleted` содержит старые строки (для DELETE и UPDATE).

#### 29. Транзакции: понятие, назначение, синтаксис
**Транзакция (Transaction)** - это логическая единица работы, состоящая из одной или нескольких операций базы данных, которые должны быть выполнены как единое целое. Транзакции обеспечивают согласованность данных, даже при параллельном доступе или системных сбоях.
* **Назначение**: Обеспечение **ACID-свойств**:
    * **Атомарность (Atomicity)**: Вся транзакция либо полностью выполняется (фиксируется - `COMMIT`), либо полностью отменяется (`ROLLBACK`). Не может быть частично выполнена.
    * **Согласованность (Consistency)**: Транзакция переводит базу данных из одного согласованного состояния в другое согласованное состояние. Все правила и ограничения целостности данных должны соблюдаться.
    * **Изоляция (Isolation)**: Параллельно выполняющиеся транзакции не должны влиять друг на друга. Результаты одной транзакции не должны быть видны другим транзакциям до ее фиксации.
    * **Долговечность (Durability)**: После того как транзакция зафиксирована, ее изменения сохраняются в базе данных навсегда, даже в случае сбоя системы.
* **Синтаксис (T-SQL)**:
    ```sql
    BEGIN TRANSACTION; -- Начинает новую транзакцию

    -- Операции базы данных внутри транзакции
    UPDATE Accounts
    SET Balance = Balance - 100
    WHERE AccountID = 123;

    UPDATE Accounts
    SET Balance = Balance + 100
    WHERE AccountID = 456;

    IF (@@ERROR = 0) -- Проверка на ошибки (упрощенная)
    BEGIN
        COMMIT TRANSACTION; -- Фиксирует все изменения, сделанные в транзакции
        PRINT 'Транзакция успешно завершена.';
    END
    ELSE
    BEGIN
        ROLLBACK TRANSACTION; -- Отменяет все изменения, сделанные в транзакции
        PRINT 'Транзакция отменена из-за ошибки.';
    END;
    ```
    * `BEGIN TRANSACTION`: Инициирует транзакцию.
    * `COMMIT TRANSACTION`: Сохраняет все изменения, сделанные с момента `BEGIN TRANSACTION`.
    * `ROLLBACK TRANSACTION`: Отменяет все изменения, сделанные с момента `BEGIN TRANSACTION`.
    * `SAVE TRANSACTION SavePointName`: Создает точку сохранения внутри транзакции, к которой можно откатиться без отмены всей транзакции.
    * `SET TRANSACTION ISOLATION LEVEL`: Устанавливает уровень изоляции для текущей транзакции.

#### 30. Индексы: понятие, назначение, синтаксис
**Индекс (Index)** - это структура данных, связанная с таблицей или представлением, которая улучшает скорость извлечения данных. Индексы создаются на одном или нескольких столбцах таблицы.
* **Понятие**: Индексы в базах данных похожи на предметный указатель в книге. Вместо того чтобы просматривать каждую страницу (строку) в книге (таблице) для поиска нужной информации, вы обращаетесь к указателю (индексу), который быстро указывает на местоположение нужной информации.
* **Назначение**:
    * **Ускорение запросов `SELECT`**: Значительно ускоряют поиск, фильтрацию и сортировку данных.
    * **Ускорение соединений (JOINs)**: Оптимизируют производительность запросов, которые соединяют таблицы по индексированным столбцам.
    * **Обеспечение уникальности**: Уникальные индексы гарантируют, что в индексированных столбцах не будет повторяющихся значений.
    * **Обеспечение порядка**: Кластеризованные индексы определяют физический порядок хранения данных.
* **Типы индексов в SQL Server**:
    * **Кластеризованный индекс (Clustered Index)**: Определяет физический порядок хранения строк в таблице. Данные таблицы физически сортируются по ключу кластеризованного индекса. Каждая таблица может иметь только один кластеризованный индекс. Он является основным способом хранения данных.
    * **Некластеризованный индекс (Non-Clustered Index)**: Является отдельной структурой от данных таблицы. Он содержит ключи индекса и указатели на фактические строки данных в таблице. Таблица может иметь множество некластеризованных индексов.
    * **Уникальный индекс (Unique Index)**: Гарантирует, что все значения в индексированном столбце (или комбинации столбцов) уникальны. Может быть как кластеризованным, так и некластеризованным.
    * **Индекс с включенными столбцами (Index with Included Columns)**: Некластеризованный индекс, который хранит дополнительные (невключенные) столбцы на листовом уровне индекса, что позволяет получать эти столбцы без доступа к базовой таблице, тем самым улучшая производительность.
    * **Filtered Index (Фильтрованный индекс)**: Некластеризованный индекс, который индексирует только подмножество строк таблицы, удовлетворяющих определенному условию. Полезен для очень больших таблиц, где запросы часто фильтруются по определенным значениям.
* **Синтаксис**:
    ```sql
    -- Создание кластеризованного индекса (обычно на Primary Key)
    CREATE CLUSTERED INDEX IX_Products_ID
    ON Products (ID);

    -- Создание некластеризованного индекса
    CREATE NONCLUSTERED INDEX IX_Products_Name
    ON Products (Name);

    -- Создание уникального некластеризованного индекса
    CREATE UNIQUE NONCLUSTERED INDEX UQ_Products_SKU
    ON Products (SKU);

    -- Создание индекса с включенными столбцами
    CREATE NONCLUSTERED INDEX IX_Orders_CustomerID_OrderDate
    ON Orders (CustomerID)
    INCLUDE (OrderDate, TotalAmount);

    -- Удаление индекса
    DROP INDEX IX_Products_Name ON Products;
    ```
    Важно помнить, что индексы занимают место на диске и требуют обслуживания при изменении данных (вставка, обновление, удаление), что может замедлять эти операции. Правильное использование индексов является ключевым для оптимизации производительности базы данных.

#### 31. SQL-роли: понятие, назначение, синтаксис
См. ответ на вопрос 25, где подробно описаны серверные роли и роли баз данных, которые являются основными типами SQL-ролей.
Кратко:
* **Понятие**: SQL-роли - это механизм управления разрешениями, который позволяет группировать пользователей и предоставлять им определенные наборы прав доступа к объектам или операциям в SQL Server.
* **Назначение**:
    * **Упрощение управления безопасностью**: Вместо предоставления разрешений каждому отдельному пользователю, разрешения назначаются роли, а затем пользователи добавляются в эту роль.
    * **Применение принципа наименьших привилегий**: Легче предоставить пользователям только те права, которые им необходимы для выполнения их задач.
    * **Гибкость**: Легко добавлять или удалять пользователей из ролей, а также изменять разрешения для ролей без изменения прав для каждого пользователя.
* **Типы**:
    * **Фиксированные серверные роли**: Предопределенные Microsoft, дают разрешения на уровне экземпляра SQL Server.
    * **Фиксированные роли базы данных**: Предопределенные Microsoft, дают разрешения на уровне конкретной базы данных.
    * **Пользовательские роли**: Создаваемые администратором для специфических потребностей.
* **Синтаксис (для пользовательских ролей)**:
    ```sql
    -- Создание новой роли базы данных
    CREATE ROLE SalesTeam;

    -- Добавление пользователей в роль
    ALTER ROLE SalesTeam ADD MEMBER User1;
    ALTER ROLE SalesTeam ADD MEMBER User2;

    -- Предоставление разрешений роли
    GRANT SELECT ON Products TO SalesTeam;
    GRANT EXECUTE ON sp_GetSalesData TO SalesTeam;

    -- Удаление пользователя из роли
    ALTER ROLE SalesTeam DROP MEMBER User1;

    -- Удаление роли
    DROP ROLE SalesTeam;
    ```
    Для серверных ролей синтаксис аналогичен, но используются `CREATE SERVER ROLE`, `ALTER SERVER ROLE` и `DROP SERVER ROLE`.

#### 32. Хранимые процедуры: понятие, назначение, синтаксис
**Хранимая процедура (Stored Procedure)** - это предварительно скомпилированный набор одной или нескольких инструкций SQL, которые хранятся в базе данных и могут быть выполнены многократно.
* **Понятие**: Представьте себе хранимую процедуру как функцию или подпрограмму в обычном языке программирования, которая оперирует данными в базе данных.
* **Назначение**:
    * **Инкапсуляция бизнес-логики**: Позволяют централизовать и управлять сложной бизнес-логикой в базе данных, а не в клиентских приложениях.
    * **Повышение производительности**: Скомпилированные хранимые процедуры выполняются быстрее, чем отдельные SQL-запросы, которые каждый раз парсятся и компилируются.
    * **Безопасность**: Пользователям можно предоставить разрешение на выполнение хранимой процедуры без предоставления прямого доступа к базовым таблицам. Это реализует принцип наименьших привилегий.
    * **Уменьшение сетевого трафика**: Несколько SQL-операций могут быть выполнены одной хранимой процедурой, что уменьшает количество обращений к базе данных.
    * **Повторное использование кода**: Одна и та же процедура может быть вызвана из разных приложений.
    * **Управление транзакциями**: Хранимые процедуры часто используются для управления транзакциями, обеспечивая атомарность нескольких операций.
* **Синтаксис**:
    ```sql
    -- Создание простой хранимой процедуры
    CREATE PROCEDURE GetProductDetails
        @ProductID INT -- Входной параметр
    AS
    BEGIN
        SET NOCOUNT ON; -- Подавляет вывод количества затронутых строк

        SELECT
            ID,
            Name,
            Description,
            ProductType,
            ExpiryDate,
            ShelfLifeDays
        FROM
            Products
        WHERE
            ID = @ProductID;
    END;
    GO

    -- Выполнение хранимой процедуры
    EXEC GetProductDetails @ProductID = 101;

    -- Создание хранимой процедуры с выходным параметром
    CREATE PROCEDURE CalculateTotalOrderAmount
        @OrderID INT,
        @TotalAmount DECIMAL(18, 2) OUTPUT -- Выходной параметр
    AS
    BEGIN
        SELECT @TotalAmount = SUM(Quantity * Price)
        FROM OrderItems
        WHERE OrderID = @OrderID;
    END;
    GO

    -- Выполнение и получение выходного параметра
    DECLARE @OrderSum DECIMAL(18, 2);
    EXEC CalculateTotalOrderAmount @OrderID = 100, @TotalAmount = @OrderSum OUTPUT;
    PRINT 'Total Amount: ' + CAST(@OrderSum AS VARCHAR);
    ```
    * `CREATE PROCEDURE`: Создает новую хранимую процедуру.
    * `ALTER PROCEDURE`: Изменяет существующую хранимую процедуру.
    * `DROP PROCEDURE`: Удаляет хранимую процедуру.
    * `EXEC` или `EXECUTE`: Выполняет хранимую процедуру.
    * Параметры могут быть входными (`INPUT` - по умолчанию), выходными (`OUTPUT`) или входными/выходными.

#### 33. Привилегии доступа и передача привилегий
**Привилегии доступа** - это конкретные права, которые предоставляются пользователям или ролям для выполнения определенных действий над объектами базы данных.
* **Типы привилегий (на уровне объектов)**:
    * `SELECT`: Право на чтение данных.
    * `INSERT`: Право на добавление новых строк.
    * `UPDATE`: Право на изменение существующих строк.
    * `DELETE`: Право на удаление строк.
    * `EXECUTE`: Право на выполнение хранимых процедур и функций.
    * `REFERENCES`: Право на создание внешних ключей, ссылающихся на таблицу или представление.
    * `ALTER`: Право на изменение схемы объекта.
    * `CONTROL`: Полный контроль над объектом.
* **Передача привилегий (GRANT OPTION)**:
    Когда пользователю предоставляются привилегии с опцией `WITH GRANT OPTION`, это означает, что этот пользователь сам может предоставлять эти же привилегии другим пользователям.
    **Синтаксис**:
    ```sql
    GRANT SELECT ON Products TO UserA WITH GRANT OPTION;
    ```
    В данном случае `UserA` теперь может не только сам выбирать данные из таблицы `Products`, но и предоставить право `SELECT` на `Products` другим пользователям.
    * **Осторожность**: Использование `WITH GRANT OPTION` требует осторожности, так как оно может привести к неконтролируемому распространению привилегий, что затрудняет управление безопасностью и может создать уязвимости. Рекомендуется использовать его только для доверенных администраторов или ролей.
    * **Отзыв (`REVOKE`)**: Когда привилегия отзывается у пользователя, который ее передал, то эта привилегия также отзывается у всех пользователей, которым он ее передал (каскадный отзыв).

#### 34. Правила синтаксиса SQL, основные типы данных
**Правила синтаксиса SQL (общие)**:
* **Нечувствительность к регистру (в большинстве случаев)**: Ключевые слова SQL, имена таблиц и столбцов обычно нечувствительны к регистру в SQL Server (хотя это может быть настроено).
* **Завершение операторов**: Операторы SQL обычно завершаются точкой с запятой (`;`). Хотя в SQL Server это часто необязательно для простых операторов, это хорошая практика и обязательно для некоторых сложных конструкций (например, для использования `WITH` Common Table Expressions).
* **Пробелы и разрывы строк**: Пробелы, символы табуляции и разрывы строк игнорируются SQL-парсером, что позволяет форматировать код для читаемости.
* **Комментарии**:
    * Однострочные: `-- Этот комментарий до конца строки`
    * Многострочные: `/* Этот комментарий может
                                занимать несколько строк */`
* **Кавычки для строк**: Строковые литералы заключаются в одинарные кавычки (`'`). Например, `'Привет, мир'`.
* **Квадратные скобки или двойные кавычки для идентификаторов**: Имена объектов, содержащие пробелы или специальные символы, или являющиеся зарезервированными словами, должны быть заключены в квадратные скобки (`[Имя Таблицы]`) или двойные кавычки (`"Имя Таблицы"` - если `QUOTED_IDENTIFIER` включен).
* **Ключевые слова**: Зарезервированные слова, такие как `SELECT`, `FROM`, `WHERE`, `AND`, `OR`, `ORDER BY`, `GROUP BY`, `JOIN`, `INSERT`, `UPDATE`, `DELETE`, `CREATE`, `ALTER`, `DROP`.

**Основные типы данных в SQL Server**:
* **Точные числовые типы**:
    * `BIT`: 0 или 1.
    * `TINYINT`: Целое число от 0 до 255.
    * `SMALLINT`: Целое число от -32,768 до 32,767.
    * `INT`: Целое число от -2,147,483,648 до 2,147,483,647.
    * `BIGINT`: Большое целое число.
    * `DECIMAL(p, s)` / `NUMERIC(p, s)`: Фиксированная точность и масштаб. `p` - общая длина, `s` - количество знаков после запятой.
    * `MONEY` / `SMALLMONEY`: Денежные значения.
* **Приблизительные числовые типы**:
    * `REAL`: Число с плавающей запятой одинарной точности.
    * `FLOAT(n)`: Число с плавающей запятой двойной точности.
* **Символьные строки**:
    * `CHAR(n)`: Строка фиксированной длины (до 8000 символов). Дополняется пробелами до `n`.
    * `VARCHAR(n)`: Строка переменной длины (до 8000 символов).
    * `VARCHAR(MAX)`: Строка переменной длины (до 2 ГБ).
    * `NCHAR(n)`: Строка фиксированной длины Unicode (до 4000 символов).
    * `NVARCHAR(n)`: Строка переменной длины Unicode (до 4000 символов).
    * `NVARCHAR(MAX)`: Строка переменной длины Unicode (до 1 ГБ).
* **Дата и время**:
    * `DATE`: Только дата (ГГГГ-ММ-ДД).
    * `TIME`: Только время (ЧЧ:ММ:СС.ффф...).
    * `SMALLDATETIME`: Дата и время (ГГГГ-ММ-ДД ЧЧ:ММ:СС), точность до минуты.
    * `DATETIME`: Дата и время (ГГГГ-ММ-ДД ЧЧ:ММ:СС.ффф), точность до 3.33 миллисекунд.
    * `DATETIME2(n)`: Дата и время (ГГГГ-ММ-ДД ЧЧ:ММ:СС.ффф...), более точная, чем `DATETIME`.
    * `DATETIMEOFFSET(n)`: Дата, время и смещение часового пояса.
* **Двоичные строки**:
    * `BINARY(n)`: Двоичные данные фиксированной длины.
    * `VARBINARY(n)`: Двоичные данные переменной длины.
    * `VARBINARY(MAX)`: Двоичные данные переменной длины (до 2 ГБ).
* **Другие типы**:
    * `UNIQUEIDENTIFIER`: Глобальный уникальный идентификатор (GUID).
    * `XML`: Для хранения XML-данных.
    * `GEOMETRY`, `GEOGRAPHY`: Для пространственных данных.
    * `TABLE`: Для возврата таблиц из функций или процедур.

#### 35. Обеспечение безопасности служб AD DS
AD DS (Active Directory Domain Services) - это служба каталогов Microsoft Windows, которая хранит информацию о сетевых ресурсах и пользователях. Обеспечение безопасности AD DS критично, так как она является центральной точкой управления для многих корпоративных ресурсов.
* **Принцип наименьших привилегий**: Предоставление пользователям и учетным записям служб только минимально необходимых прав.
* **Использование надежных паролей и политик паролей**: Принудительное использование сложных паролей, регулярная смена паролей, блокировка учетных записей после нескольких неудачных попыток.
* **Многофакторная аутентификация (MFA)**: Внедрение MFA для администраторов и критически важных учетных записей.
* **Регулярное обновление системы**: Установка последних исправлений безопасности и обновлений для контроллеров домена.
* **Мониторинг событий безопасности**: Отслеживание журналов событий безопасности на контроллерах домена для выявления подозрительной активности (например, неудачные попытки входа, изменения в групповых политиках).
* **Делегирование администрирования**: Делегирование прав администрирования на более гранулярном уровне вместо предоставления полных прав доменного администратора.
* **Резервное копирование AD DS**: Регулярное создание резервных копий системного состояния контроллеров домена.
* **Физическая безопасность**: Защита физического доступа к контроллерам домена.
* **Разделение ролей**: Разделение обязанностей между несколькими администраторами, чтобы один человек не имел полного контроля.
* **Защита контроллеров домена**: Контроллеры домена должны быть максимально защищены, с минимальным количеством установленного ПО, только необходимыми сетевыми портами.
* **Групповые политики**: Использование групповых политик для централизованного управления параметрами безопасности пользователей и компьютеров в домене.

#### 36. Мониторинг, управление и восстановление AD DS
* **Мониторинг AD DS**:
    * **Журналы событий**: Регулярный просмотр журналов событий безопасности, системы и каталога на контроллерах домена (например, ошибки репликации, сбои аутентификации, изменения важных объектов).
    * **Performance Monitor (Perfmon)**: Отслеживание метрик производительности контроллеров домена (загрузка ЦП, использование памяти, дисковая активность, сетевой трафик, очереди LDAP запросов).
    * **Active Directory Replication Status Tool**: Для проверки состояния репликации между контроллерами домена.
    * **DCDiag**: Инструмент командной строки для диагностики работоспособности контроллеров домена.
    * **SCOM (System Center Operations Manager)** или другие сторонние решения для централизованного мониторинга.
* **Управление AD DS**:
    * **Консоли управления**: Active Directory Users and Computers, Active Directory Sites and Services, Active Directory Domains and Trusts, Group Policy Management Console (GPMC).
    * **PowerShell**: Мощный инструмент для автоматизации задач управления AD DS.
    * **Командная строка**: `dsadd`, `dsmod`, `dsmove`, `dsquery` и другие.
    * **Групповые политики (Group Policies)**: Централизованное управление конфигурацией пользователей и компьютеров.
    * **Делегирование управления**: Предоставление ограниченных административных прав.
* **Восстановление AD DS**:
    * **Резервное копирование системного состояния**: Регулярное создание резервных копий системного состояния контроллеров домена, которое включает AD DS базу данных, реестр, SYSVOL.
    * **Авторитетное восстановление (Authoritative Restore)**: Используется, когда нужно восстановить объект AD, который был случайно удален или изменен, и эти изменения реплицировались на другие контроллеры домена. Восстановленный объект помечается как "авторитетный", и его версия затем реплицируется на все остальные контроллеры.
    * **Неавторитетное восстановление (Non-Authoritative Restore)**: Используется для восстановления контроллера домена после сбоя оборудования или программного обеспечения. После восстановления базы данных AD DS она синхронизируется с другими контроллерами домена.
    * **Восстановление на уровне объектов**: Восстановление отдельных объектов AD (пользователей, групп) с помощью корзины Active Directory (Active Directory Recycle Bin) или сторонних инструментов.
    * **Подготовка к авариям**: Наличие плана аварийного восстановления и его регулярное тестирование.

#### 37. Внедрение групповых политик
**Групповые политики (Group Policies)** - это функция Active Directory, которая предоставляет централизованное управление и настройку операционных систем, приложений и учетных записей пользователей в среде Active Directory.
* **Понятие объекта групповой политики (GPO - Group Policy Object)**: Контейнер, который содержит настройки политики. GPO могут быть связаны с доменами, организационными единицами (OU) или сайтами.
* **Принципы внедрения**:
    1.  **Планирование**: Определение необходимых настроек, структуры OU, иерархии GPO, и правил наследования.
    2.  **Создание GPO**: Использование консоли управления групповыми политиками (GPMC) для создания новых GPO.
    3.  **Редактирование GPO**: Настройка параметров политики (например, политики паролей, параметры безопасности, развертывание ПО, скрипты запуска/завершения).
    4.  **Связывание GPO**: Привязка GPO к домену, OU или сайту.
        * **Домен**: Политики применяются ко всем пользователям и компьютерам в домене.
        * **Организационная единица (OU)**: Политики применяются только к объектам внутри этой OU. Это основной способ гранулярного управления.
        * **Сайт**: Политики применяются к пользователям и компьютерам в пределах определенного сайта Active Directory (географического расположения).
    5.  **Наследование и принуждение (Enforcement)**: Политики наследуются от родительских контейнеров к дочерним. Принуждение (Enforced) GPO предотвращает переопределение политики дочерними GPO.
    6.  **Фильтрация безопасности**: Применение GPO только к определенным группам пользователей или компьютеров с помощью фильтрации безопасности.
    7.  **WMI-фильтрация (Windows Management Instrumentation)**: Применение GPO на основе критериев WMI (например, версия ОС, модель компьютера).
    8.  **Тестирование**: Всегда тестировать GPO в тестовой среде перед развертыванием в рабочей.
    9.  **Мониторинг и устранение неполадок**: Использование `gpresult` для просмотра примененных политик, Event Viewer для отслеживания ошибок применения политик, и Group Policy Modeling/Results Wizard в GPMC.

#### 38. Управление параметрами пользователей с помощью групповых политик
Групповые политики предоставляют мощные возможности для управления параметрами пользовательской среды:
* **Политики паролей**: Принуждение к использованию сложных паролей, определение минимальной длины пароля, срока действия, истории паролей.
* **Перенаправление папок (Folder Redirection)**: Перенаправление пользовательских папок (например, "Мои документы", "Рабочий стол") на сетевые ресурсы, что упрощает резервное копирование и доступ к данным с разных компьютеров.
* **Скрипты входа/выхода**: Запуск скриптов при входе или выходе пользователя для выполнения задач автоматизации (например, подключение сетевых дисков, установка переменных среды).
* **Ограничения на установку программ**: Запрет пользователям устанавливать программное обеспечение.
* **Настройки рабочего стола**: Установка фонового рисунка, заставки, ограничение доступа к элементам панели управления.
* **Настройки безопасности**: Контроль учетных записей пользователей (UAC), настройки брандмауэра, параметры аудита.
* **Развертывание программного обеспечения**: Автоматическое развертывание программ MSI-пакетов для пользователей.
* **Настройки Internet Explorer / Microsoft Edge**: Управление домашней страницей, прокси-сервером, параметрами безопасности браузера.
* **Сопоставление сетевых дисков**: Автоматическое подключение сетевых папок для пользователей.
* **Настройки реестра**: Изменение любых параметров реестра Windows для пользователей.
* **Настройки принтеров**: Автоматическое развертывание сетевых принтеров.

#### 39. Обеспечение безопасного доступа к общим файлам
Обеспечение безопасного доступа к общим файлам в сетевой среде включает несколько уровней контроля:
* **Разрешения NTFS (NTFS Permissions)**:
    * Применяются к файлам и папкам на уровне файловой системы.
    * Очень гранулярны: позволяют контролировать доступ на чтение, запись, выполнение, изменение, полный контроль.
    * Сохраняются при перемещении файлов в пределах одного тома NTFS и при доступе к файлам по сети или локально.
    * Рекомендуется использовать разрешения NTFS для обеспечения основного уровня безопасности.
* **Разрешения общего доступа (Share Permissions)**:
    * Применяются к общим папкам (шарам), которые доступны по сети.
    * Менее гранулярны, чем NTFS: обычно "Полный контроль", "Изменение", "Чтение".
    * Применяются только при доступе к файлам через сетевой ресурс. Локальный доступ не затрагивается.
    * **Принцип наименьших привилегий**: Результирующие разрешения для пользователя, получающего доступ к общему файлу, являются пересечением разрешений общего доступа и разрешений NTFS (применяется наиболее ограничительное разрешение).
    * **Рекомендация**: Настраивать разрешения общего доступа на `Everyone: Full Control` или `Authenticated Users: Full Control`, а затем использовать более строгие разрешения NTFS для реального контроля доступа. Это упрощает администрирование и позволяет NTFS полностью контролировать безопасность.
* **Групповые политики**: Используются для централизованного управления разрешениями на общие папки, настройки аудита доступа к файлам и принуждения к политике безопасности.
* **Аудит доступа к объектам**: Настройка аудита в групповых политиках для отслеживания успешных и неудачных попыток доступа к файлам и папкам.
* **Шифрование**: Использование EFS (Encrypting File System) или BitLocker для шифрования данных на дисках.
* **Защита от вредоносных программ**: Использование антивирусного ПО и систем обнаружения/предотвращения вторжений.
* **Ограничение доступа к общей папке администратора (ADMIN$)**: Административные общие папки (например, C$, ADMIN$) по умолчанию доступны только администраторам. Важно не изменять их разрешения без крайней необходимости.

#### 40. Установка и настройка SQL-сервера
Установка и настройка SQL Server - это многошаговый процесс:
* **Планирование**:
    * Определение требований к оборудованию и программному обеспечению.
    * Выбор правильной версии и редакции SQL Server.
    * Планирование компонентов для установки (Database Engine, SSIS, SSAS, SSRS и т.д.).
    * Выбор режима аутентификации (Windows Authentication, Mixed Mode).
    * Определение учетных записей служб для SQL Server (рекомендуется использовать отдельные учетные записи домена с минимальными привилегиями).
    * Планирование путей для файлов данных и журналов.
* **Установка (использование мастера установки SQL Server)**:
    1.  Запуск установочного носителя SQL Server.
    2.  Выбор "Installation" -> "New SQL Server stand-alone installation or add features to an existing installation".
    3.  Принятие лицензионных условий.
    4.  Выбор компонентов для установки.
    5.  Настройка экземпляра (именованный или по умолчанию).
    6.  Настройка учетных записей служб (Service Accounts) и правил сортировки (Collation).
    7.  Настройка конфигурации ядра СУБД (Database Engine Configuration):
        * **Режим аутентификации**: Windows Authentication Mode или Mixed Mode (если выбран смешанный режим, необходимо задать пароль для учетной записи `sa`).
        * **Администраторы SQL Server**: Указать учетные записи Windows, которые будут иметь права `sysadmin`.
        * **Пути к данным**: Указать пути для файлов данных, файлов журналов и временных файлов (`tempdb`).
        * **Параметры `tempdb`**: Настроить количество файлов данных `tempdb`, их начальный размер и прирост.
    8.  Настройка других компонентов (SSIS, SSAS, SSRS), если выбраны.
    9.  Завершение установки.
* **Первоначальная настройка после установки**:
    * **Установка последних пакетов обновлений (Service Packs) и накопительных обновлений (Cumulative Updates)**.
    * **Настройка параметров памяти**: Ограничение максимального потребления памяти SQL Server, чтобы не конкурировать с ОС.
    * **Настройка `tempdb`**: Оптимизация количества файлов `tempdb` (обычно равно количеству логических ядер ЦП до 8).
    * **Настройка модели восстановления**: Установка подходящей модели восстановления для каждой базы данных (Full, Simple, Bulk-Logged).
    * **Настройка резервного копирования**: Планирование регулярных резервных копий.
    * **Конфигурация сетевых протоколов**: Включение необходимых протоколов (TCP/IP, Named Pipes).
    * **Настройка брандмауэра**: Открытие портов (по умолчанию 1433 для TCP/IP) для доступа к SQL Server.
    * **Создание логинов и пользователей**: Настройка безопасности.
    * **Мониторинг**: Настройка средств мониторинга производительности.

#### 41. Импорт и экспорт данных
Импорт и экспорт данных - это процессы перемещения данных между SQL Server и другими источниками/приемниками данных.
* **Методы импорта/экспорта в SQL Server**:
    * **SQL Server Import and Export Wizard (Мастер импорта и экспорта SQL Server)**:
        * Графический инструмент, который предоставляет пошаговый интерфейс для импорта/экспорта данных из различных источников (текстовые файлы, Excel, другие базы данных, ODBC, OLE DB).
        * Позволяет сопоставлять столбцы, преобразовывать типы данных и сохранять пакеты SSIS.
    * **BULK INSERT**:
        * T-SQL команда для быстрого импорта больших объемов данных из текстового файла в таблицу SQL Server.
        * Очень эффективен, так как минимально протоколируется в bulk-logged модели восстановления.
        * **Синтаксис**:
            ```sql
            BULK INSERT YourTable
            FROM 'C:\Data\YourData.csv'
            WITH (
                FIELDTERMINATOR = ',',
                ROWTERMINATOR = '\n',
                FIRSTROW = 2 -- Пропустить заголовок
            );
            ```
    * **BCP (Bulk Copy Program)**:
        * Утилита командной строки для массового копирования данных между экземпляром SQL Server и файлом данных.
        * Позволяет как импортировать, так и экспортировать данные.
        * Подходит для автоматизации и скриптов.
        * **Пример экспорта**:
            `bcp "SELECT * FROM YourDatabase.dbo.YourTable" queryout "C:\Data\ExportedData.csv" -c -t, -S YourServerName -T`
        * **Пример импорта**:
            `bcp YourDatabase.dbo.YourTable in "C:\Data\ImportData.csv" -c -t, -S YourServerName -T`
    * **SQL Server Integration Services (SSIS)**:
        * Платформа ETL (Extract, Transform, Load) для создания сложных пакетов, которые могут извлекать данные из различных источников, преобразовывать их и загружать в назначение.
        * Используется для регулярных, сложных и высокопроизводительных задач импорта/экспорта.
    * **OPENROWSET / OPENDATASOURCE**:
        * T-SQL функции, позволяющие выполнять распределенные запросы к данным, хранящимся вне SQL Server (например, текстовые файлы, Excel, другие базы данных).
    * **Linked Servers (Связанные серверы)**:
        * Позволяют SQL Server запрашивать данные из других экземпляров SQL Server или других СУБД (Oracle, MySQL) так, как будто они являются локальными таблицами.

#### 42. Выполнение мониторинга SQL Server с использованием оповещений и предупреждений
Мониторинг SQL Server с использованием оповещений и предупреждений (Alerts and Notifications) - это проактивный подход к управлению производительностью и доступностью базы данных.
* **Назначение**:
    * **Раннее обнаружение проблем**: Выявление потенциальных проблем (например, нехватка дискового пространства, высокая загрузка ЦП, ошибки в журнале ошибок SQL Server) до того, как они станут критическими.
    * **Своевременное реагирование**: Автоматическое или полуавтоматическое информирование администраторов о важных событиях.
    * **Улучшение производительности**: Определение узких мест и аномалий в работе сервера.
* **Компоненты мониторинга в SQL Server**:
    * **SQL Server Agent**: Служба, которая выполняет запланированные задания, а также управляет оповещениями и операторами.
    * **Оповещения (Alerts)**: Определяют условия, при которых генерируется уведомление. Оповещения могут быть основаны на:
        * **Событиях журнала ошибок SQL Server (SQL Server Error Log Events)**: Отслеживание определенных номеров ошибок (например, 1105 для нехватки места, 823/824 для ошибок ввода/вывода).
        * **Счетчиках производительности (Performance Counters)**: Мониторинг значений счетчиков производительности (например, загрузка ЦП, свободное место на диске, количество блокировок).
        * **Событиях WMI (Windows Management Instrumentation)**: Мониторинг системных событий Windows.
    * **Операторы (Operators)**: Определяют, кто должен получать уведомления и каким способом (электронная почта, пейджер, net send). Операторы могут быть отдельными лицами или группами.
    * **Уведомления (Notifications)**: Метод доставки информации об оповещении операторам.
* **Практика мониторинга**:
    1.  **Определение критических метрик**: Какие аспекты работы SQL Server являются наиболее важными для отслеживания.
    2.  **Настройка оповещений**: Создание оповещений для ключевых ошибок и пороговых значений производительности. Например:
        * Оповещение о заполнении журнала транзакций.
        * Оповещение о низком свободном месте на диске.
        * Оповещение о дедлоках (взаимных блокировках).
        * Оповещение о высокой загрузке ЦП или памяти.
    3.  **Настройка операторов**: Создание операторов и указание их контактных данных.
    4.  **Связывание оповещений с операторами**: Назначение операторов для получения уведомлений от определенных оповещений.
    5.  **Регулярный просмотр журналов**: Просмотр журналов ошибок SQL Server, журналов событий Windows и журналов SQL Server Agent.
    6.  **Использование расширенных инструментов**: SQL Server Management Studio (SSMS) для графического интерфейса, System Center Operations Manager (SCOM), Azure Monitor, сторонние решения для комплексного мониторинга.

#### 43. Современные инструментальные средства проектирования схемы базы данных
Современные инструментальные средства проектирования схемы базы данных значительно упрощают процесс моделирования, создания и управления базами данных. Они предлагают графические интерфейсы, функции реверс-инжиниринга, генерации кода и интеграцию с СУБД.
* **Microsoft SQL Server Management Studio (SSMS)**:
    * Встроенный инструмент для управления и администрирования SQL Server.
    * Включает дизайнеры таблиц, представлений, хранимых процедур.
    * Позволяет создавать диаграммы базы данных (Database Diagrams) для визуализации связей между таблицами.
    * Имеет функции для создания DDL-скриптов.
* **SQL Server Data Tools (SSDT) for Visual Studio**:
    * Расширение Visual Studio, которое предоставляет интегрированную среду разработки для баз данных.
    * Позволяет создавать проекты баз данных, управлять схемой базы данных, использовать сравнение схем (Schema Compare), публиковать изменения в базе данных.
    * Поддерживает концепцию "состояния" базы данных и автоматизирует создание скриптов обновления.
* **DbVisualizer / DataGrip / DBeaver**:
    * Кроссплатформенные универсальные клиенты баз данных, которые поддерживают множество СУБД (SQL Server, MySQL, PostgreSQL, Oracle и т.д.).
    * Предлагают функции проектирования схемы (визуальный редактор таблиц, диаграммы ERD), выполнения запросов, управления данными, импорта/экспорта.
* **ER/Studio (Embarcadero)**:
    * Мощное и профессиональное CASE-средство для моделирования данных.
    * Поддерживает концептуальное, логическое и физическое моделирование.
    * Позволяет генерировать DDL-скрипты для различных СУБД, выполнять реверс-инжиниринг существующих баз данных.
    * Поддерживает сравнение и синхронизацию моделей и баз данных.
* **PowerDesigner (SAP)**:
    * Еще одно ведущее CASE-средство для корпоративного моделирования, включая моделирование данных.
    * Поддерживает широкий спектр моделей (процессные, информационные, объектно-ориентированные, архитектурные).
    * Может генерировать DDL, отслеживать изменения, интегрироваться с другими инструментами.
* **Lucidchart / Draw.io (или их аналоги)**:
    * Онлайн-инструменты для создания различных диаграмм, включая ERD.
    * Не являются специализированными средствами для проектирования баз данных, но полезны для быстрого визуального моделирования.
* **DBSchema**: Инструмент для проектирования, документирования и сравнения схем баз данных, поддерживает множество СУБД.

---

#### Задание: Создайте базу данных "Производственных цех" для хранения информации о производимой продукции.

**Создайте следующие таблицы:** 
* **Таблица "Продукция"**: ID (идентификатор), Название, Описание, Тип продукции, Дата окончания срока годности, Срок годности (дней)
* **Таблица "Производство"**: ID (идентификатор), Дата, Количество продукции, ID продукции, ID оборудования, Стоимость
* **Таблица "Оборудование"**: ID (идентификатор), Название, Тип.

**Заполните каждую таблицу минимум тремя записями.** 

**Создайте роль "СотрудникПроизводства" с правами на выборку и обновление данных из всех таблиц.** 

**Напишите запросы с использованием переменных:** 
* **Создайте переменную @ResearchName и запишите в нее название продукции.** 
* **Используя переменную @ResearchName, выведите информацию о продукции с наибольшим сроком годности.** 

**Напишите пользовательскую функцию для подсчета общей стоимости производства определенного типа продукции.** 

```sql
-- 1. Создание базы данных "Производственных цех"
USE master;
GO

IF DB_ID('ПроизводственныйЦех') IS NOT NULL
DROP DATABASE ПроизводственныйЦех;
GO

CREATE DATABASE ПроизводственныйЦех;
GO

USE ПроизводственныйЦех;
GO

-- 2. Создание таблицы "Оборудование"
CREATE TABLE Оборудование (
    ID INT PRIMARY KEY IDENTITY(1,1),
    Название NVARCHAR(255) NOT NULL,
    Тип NVARCHAR(100)
);

-- 3. Создание таблицы "Продукция"
CREATE TABLE Продукция (
    ID INT PRIMARY KEY IDENTITY(1,1),
    Название NVARCHAR(255) NOT NULL,
    Описание NVARCHAR(MAX),
    ТипПродукции NVARCHAR(100),
    ДатаОкончанияСрокаГодности DATE,
    СрокГодностиДней INT
);

-- 4. Создание таблицы "Производство"
CREATE TABLE Производство (
    ID INT PRIMARY KEY IDENTITY(1,1),
    Дата DATE NOT NULL,
    КоличествоПродукции INT NOT NULL,
    IDПродукции INT NOT NULL,
    IDОборудования INT NOT NULL,
    Стоимость DECIMAL(18, 2) NOT NULL,
    CONSTRAINT FK_Производство_Продукция FOREIGN KEY (IDПродукции) REFERENCES Продукция(ID),
    CONSTRAINT FK_Производство_Оборудование FOREIGN KEY (IDОборудования) REFERENCES Оборудование(ID)
);
GO

-- 5. Заполнение таблицы "Оборудование"
INSERT INTO Оборудование (Название, Тип) VALUES
('Станок ЧПУ-1000', 'Фрезеровочный'),
('Линия сборки АВТ-200', 'Сборочный'),
('Пресс гидравлический ПГ-50', 'Формовочный');

-- 6. Заполнение таблицы "Продукция"
INSERT INTO Продукция (Название, Описание, ТипПродукции, ДатаОкончанияСрокаГодности, СрокГодностиДней) VALUES
('Деталь К-1', 'Комплектующая для агрегата А', 'Комплектующая', '2025-12-31', 180),
('Готовый Продукт А', 'Основной готовый продукт', 'Готовая Продукция', '2026-06-15', 365),
('Сырье XYZ', 'Сырье для производства деталей', 'Сырье', '2025-09-30', 90);

-- 7. Заполнение таблицы "Производство"
INSERT INTO Производство (Дата, КоличествоПродукции, IDПродукции, IDОборудования, Стоимость) VALUES
('2025-01-10', 100, 1, 1, 15000.00),
('2025-01-12', 50, 2, 2, 25000.00),
('2025-01-15', 200, 3, 3, 10000.00);
GO

-- 8. Создание роли "СотрудникПроизводства" с правами на выборку и обновление
-- Сначала создадим логин для примера, если его нет (для демонстрации)
-- CREATE LOGIN СотрудникПроизводства_Login WITH PASSWORD = 'YourSecurePassword123!', CHECK_POLICY = OFF;
-- GO

-- Создание пользователя базы данных и привязка его к логину (если используется SQL Server Authentication)
-- CREATE USER СотрудникПроизводства_User FOR LOGIN СотрудникПроизводства_Login;
-- GO

-- Создание роли базы данных
CREATE ROLE СотрудникПроизводства;
GO

-- Предоставление прав на выборку и обновление для всех таблиц
GRANT SELECT, UPDATE ON Оборудование TO СотрудникПроизводства;
GRANT SELECT, UPDATE ON Продукция TO СотрудникПроизводства;
GRANT SELECT, UPDATE ON Производство TO СотрудникПроизводства;
GO

-- Добавление пользователя в роль (замените 'YourDatabaseUser' на реального пользователя, если вы его создавали)
-- ALTER ROLE СотрудникПроизводства ADD MEMBER СотрудникПроизводства_User;
-- GO

-- 9. Запросы с использованием переменных
-- Создайте переменную @ResearchName и запишите в нее название продукции.
DECLARE @ResearchName NVARCHAR(255);
SET @ResearchName = N'Деталь К-1'; -- Записываем название продукции

-- Используя переменную @ResearchName, выведите информацию о продукции с наибольшим сроком годности.
SELECT TOP 1
    ID,
    Название,
    Описание,
    ТипПродукции,
    ДатаОкончанияСрокаГодности,
    СрокГодностиДней
FROM
    Продукция
WHERE
    Название = @ResearchName
ORDER BY
    СрокГодностиДней DESC;

-- Выведем для всех продуктов, чтобы показать наибольший срок годности в целом
PRINT N'Информация о продукте с наибольшим сроком годности (среди всех, не только по @ResearchName):';
SELECT TOP 1
    ID,
    Название,
    Описание,
    ТипПродукции,
    ДатаОкончанияСрокаГодности,
    СрокГодностиДней
FROM
    Продукция
ORDER BY
    СрокГодностиДней DESC;
GO

-- 10. Пользовательская функция для подсчета общей стоимости производства определенного типа продукции
CREATE FUNCTION dbo.CalculateTotalProductionCostByType
(
    @ProductType NVARCHAR(100)
)
RETURNS DECIMAL(18, 2)
AS
BEGIN
    DECLARE @TotalCost DECIMAL(18, 2);

    SELECT @TotalCost = SUM(P.Стоимость)
    FROM Производство AS P
    JOIN Продукция AS Prod ON P.IDПродукции = Prod.ID
    WHERE Prod.ТипПродукции = @ProductType;

    -- Если нет продукции такого типа, вернуть 0
    IF @TotalCost IS NULL
        SET @TotalCost = 0;

    RETURN @TotalCost;
END;
GO

-- Пример использования функции:
SELECT dbo.CalculateTotalProductionCostByType(N'Комплектующая') AS TotalCostForComponents;
SELECT dbo.CalculateTotalProductionCostByType(N'Готовая Продукция') AS TotalCostForFinishedGoods;
SELECT dbo.CalculateTotalProductionCostByType(N'НесуществующийТип') AS TotalCostForNonExistentType;
