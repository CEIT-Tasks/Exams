#### 1. Создайте базу данных "Производственных цех" для хранения информации о производимой продукции

```sql
-- Создание базы данных
USE master;
GO

IF DB_ID('ПроизводственныйЦех') IS NOT NULL
DROP DATABASE ПроизводственныйЦех;
GO

CREATE DATABASE ПроизводственныйЦех;
GO
````

#### 2. Создайте следующие таблицы:

- **Таблица "Продукция"**: ID (идентификатор), Название, Описание, Тип продукции, Дата окончания срока годности, Срок годности (дней)
- **Таблица "Производство"**: ID (идентификатор), Дата, Количество продукции, ID продукции, ID оборудования, Стоимость
- **Таблица "Оборудование"**: ID (идентификатор), Название, Тип.

```sql
USE ПроизводственныйЦех;
GO

-- Создание таблицы "Оборудование"
CREATE TABLE Оборудование (
    ID INT PRIMARY KEY IDENTITY(1,1),
    Название NVARCHAR(100) NOT NULL,
    Тип NVARCHAR(50)
);
GO

-- Создание таблицы "Продукция"
CREATE TABLE Продукция (
    ID INT PRIMARY KEY IDENTITY(1,1),
    Название NVARCHAR(255) NOT NULL,
    Описание NVARCHAR(MAX),
    ТипПродукции NVARCHAR(50),
    ДатаОкончанияСрокаГодности DATE,
    СрокГодности INT
);
GO

-- Создание таблицы "Производство" с внешними ключами
CREATE TABLE Производство (
    ID INT PRIMARY KEY IDENTITY(1,1),
    Дата DATE NOT NULL,
    КоличествоПродукции INT NOT NULL,
    IDПродукции INT NOT NULL,
    IDОборудования INT NOT NULL,
    Стоимость DECIMAL(18, 2) NOT NULL,
    CONSTRAINT FK_Производство_Продукция FOREIGN KEY (IDПродукции) REFERENCES Продукция(ID),
    CONSTRAINT FK_Производство_Оборудование FOREIGN KEY (IDОборудования) REFERENCES Оборудование(ID)
);
GO
```

#### 3. Заполните каждую таблицу минимум тремя записями.

```sql
-- Заполнение таблицы "Оборудование"
INSERT INTO Оборудование (Название, Тип) VALUES
('Оборудование 1', 'Тип A'),
('Оборудование 2', 'Тип B'),
('Оборудование 3', 'Тип A');
GO

-- Заполнение таблицы "Продукция"
INSERT INTO Продукция (Название, Описание, ТипПродукции, ДатаОкончанияСрокаГодности, СрокГодности) VALUES
('Продукт А', 'Описание продукта А', 'Тип 1', '2025-12-31', 365),
('Продукт Б', 'Описание продукта Б', 'Тип 2', '2025-06-30', 180),
('Продукт В', 'Описание продукта В', 'Тип 1', '2025-09-15', 270);
GO

-- Заполнение таблицы "Производство"
INSERT INTO Производство (Дата, КоличествоПродукции, IDПродукции, IDОборудования, Стоимость) VALUES
('2025-01-01', 100, 1, 1, 5000.00),
('2025-02-01', 150, 2, 2, 7500.00),
('2025-03-01', 200, 3, 3, 10000.00);
GO
```

#### 4. Создайте роль "СотрудникПроизводства" с правами на выборку и обновление данных из всех таблиц.

```sql
-- Создание роли базы данных
CREATE ROLE СотрудникПроизводства;
GO

-- Предоставление прав на выборку и обновление для всех таблиц
GRANT SELECT, UPDATE ON Продукция TO СотрудникПроизводства;
GRANT SELECT, UPDATE ON Производство TO СотрудникПроизводства;
GRANT SELECT, UPDATE ON Оборудование TO СотрудникПроизводства;
GO
```

#### 5. Напишите запросы с использованием переменных:

- **Создайте переменную `@ResearchName` и запишите в нее название продукции.**
- **Используя переменную `@ResearchName`, выведите информацию о продукции с наибольшим сроком годности.**

```sql
-- Создание переменной @ResearchName и запись в нее названия продукции
DECLARE @ResearchName NVARCHAR(100);
SET @ResearchName = N'Продукт А'; -- Меняется на реальное значение
GO

-- Вывод информации о продукции с наибольшим сроком годности, используя @ResearchName
SELECT TOP 1 *
FROM Продукция
WHERE Название = @ResearchName
ORDER BY СрокГодности DESC;
GO
```

#### 6. Напишите пользовательскую функцию для подсчета общей стоимости производства определенного типа продукции.

```sql
-- Пользовательская функция для подсчета общей стоимости производства определенного типа продукции
CREATE FUNCTION dbo.ОбщаяСтоимостьПоТипуПродукции (@ТипПродукции NVARCHAR(50))
RETURNS DECIMAL(18,2)
AS
BEGIN
    DECLARE @ОбщаяСтоимость DECIMAL(18,2);

    SELECT @ОбщаяСтоимость = SUM(Производство.Стоимость)
    FROM Производство
    JOIN Продукция ON Производство.IDПродукции = Продукция.ID
    WHERE Продукция.ТипПродукции = @ТипПродукции;

    -- Если нет продукции такого типа, вернуть 0
    IF @ОбщаяСтоимость IS NULL
        SET @ОбщаяСтоимость = 0;

    RETURN @ОбщаяСтоимость;
END;
GO

-- Вызов функции
SELECT dbo.ОбщаяСтоимостьПоТипуПродукции(N'Тип 1') AS ОбщаяСтоимость;
GO
```

#### 7. Дополнительное задание: Написать пользовательскую процедуру, где вы вычитаете разницу из срока годности.

```sql
-- Пользовательская процедура для вычисления разницы сроков годности
CREATE PROCEDURE dbo.ВычислитьРазницуСроковГодности
    @IDПродукции1 INT,
    @IDПродукции2 INT
AS
BEGIN
    DECLARE @СрокГодности1 INT;
    DECLARE @СрокГодности2 INT;
    DECLARE @Разница INT;

    SELECT @СрокГодности1 = СрокГодности
    FROM Продукция
    WHERE ID = @IDПродукции1;

    SELECT @СрокГодности2 = СрокГодности
    FROM Продукция
    WHERE ID = @IDПродукции2;

    SET @Разница = ABS(@СрокГодности1 - @СрокГодности2);

    SELECT @Разница AS РазницаСроковГодности;
END;
GO

-- Вызов процедуры
EXEC dbo.ВычислитьРазницуСроковГодности @IDПродукции1 = 1, @IDПродукции2 = 2;
GO
```

#### 8. Дополнительное задание: Создать триггер, который при изменении фамилии пациента фиксирует в некоторой таблице информацию о его прошлой фамилии, новой фамилии, а также дату и время обновления данных в таблице.

- **Важно:** Для этого триггера предполагается наличие таблицы `People` с полем `Фамилия` и `ID_пациента`, а также необходимость предварительно создать таблицу `История_изменений`.


```sql
-- Сначала создадим пример таблицы People (если её нет)
IF OBJECT_ID('People') IS NOT NULL
DROP TABLE People;
GO

CREATE TABLE People (
    ID_пациента INT PRIMARY KEY IDENTITY(1,1),
    Имя NVARCHAR(50),
    Фамилия NVARCHAR(50)
);
GO

INSERT INTO People (Имя, Фамилия) VALUES
('Иван', 'Иванов'),
('Петр', 'Петров'),
('Анна', 'Сидорова');
GO

-- Создание таблицы История_изменений
IF OBJECT_ID('История_изменений') IS NOT NULL
DROP TABLE История_изменений;
GO

CREATE TABLE История_изменений (
    ID_пациента INT,
    Старая_фамилия NVARCHAR(50),
    Новая_фамилия NVARCHAR(50),
    Дата_изменения DATETIME
);
GO

-- Создание триггера Изменение_фамилии
CREATE TRIGGER Изменение_фамилии
ON People
AFTER UPDATE
AS
BEGIN
    -- Проверяем, изменилась ли фамилия
    IF UPDATE(Фамилия)
    BEGIN
        INSERT INTO История_изменений (ID_пациента, Старая_фамилия, Новая_фамилия, Дата_изменения)
        SELECT
            i.ID_пациента,
            d.Фамилия,
            i.Фамилия,
            GETDATE()
        FROM
            inserted i
        INNER JOIN
            deleted d ON i.ID_пациента = d.ID_пациента
        WHERE
            i.Фамилия <> d.Фамилия;
    END;
END;
GO

-- Запрос для проверки триггера
UPDATE People
SET Фамилия = N'Вернк'
WHERE ID_пациента = 1;

-- Проверка содержимого таблицы История_изменений
SELECT * FROM История_изменений;
GO

-- Проверка, что триггер не сработает при отсутствии изменения фамилии
UPDATE People
SET Имя = N'Иван Новый'
WHERE ID_пациента = 1;

SELECT * FROM История_изменений;
GO
```