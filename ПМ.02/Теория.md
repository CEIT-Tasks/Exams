### Теоретические вопросы к экзамену ПМ.02

**1. Понятия требований к разработке ПО, классификация, уровни требований.**

**Требование к программному обеспечению (ПО)** — это характеристика или свойство ПО, определенное контрактом на его разработку или другим документом (стандартом, спецификацией и т. п.). Это характеристика, с помощью которой конечный пользователь ПО решает какую-либо задачу или достигает определенной цели.

**Классификация требований:**
*   **Требования к продукту и процессу:** условия выполнения и режим работы ПО, ограничения на среду исполнения, определение принципов взаимодействия с другими программами.
*   **Функциональные требования:** определяют назначение и функции системы.
*   **Нефункциональные требования:** определяют условия исполнения ПО, его переносимость и доступ к данным.
*   **Системные требования:** требования, предъявляемые к программной системе в целом.

**2. Методологии и стандарты, регламентирующие работу с требованиями.**

Область, занимающаяся формулировкой, документированием и поддержкой требований к ПО, называется **Инженерия требований** (Requirements engineering). Стандарт ISO/IEC TR 19759:2005 соответствует **Ядру знаний SWEBOK** (Software Engineering Body of Knowledge), который является основным научно-техническим документом по программной инженерии и охватывает, в том числе, и инженерию требований.

**3. Методы организации работы в команде разработчиков.**

Гибкая методология (Agile) основана на принципах, касающихся организации работы команды. К ним относятся:
*   **Деятельность в команде**.
*   Приоритет **личности и взаимодействия** над процессами и инструментами,.
*   **Многофункциональность** каждого исполнителя (проектирование, кодирование, тестирование и т.д.).
*   Важность **самоорганизации** и взаимодействия между разработчиками.
*   Применяются такие методы, как **парное программирование** (первый разработчик пишет код, второй его проверяет на правильность),.

**4. Тестовое покрытие. Тестовый сценарий, тестовый пакет.**

**Тестовое покрытие** является продуктовой метрикой, которая измеряет степень покрытия тестами строк, ветвей, условий и путей.
**Тест** — это набор входных данных и прочих условий (например, характеристики операционной системы и оборудования), которые полностью определяют ход выполнения программы.
Создание **тестовых сценариев** и составление **тестовых пакетов** являются этапами управления тестированием.

**5. Унифицированный язык моделирования UML. Нотации.**

**UML** (Unified Modeling Language) — язык моделирования, используемый для описания элементов ПО с помощью **нотаций проектирования**. Элементами UML являются сущности (классы, интерфейсы, компоненты), отношения (ассоциации, обобщения) и диаграммы.
Выделяют **структурную нотацию**, которая представляет основные аспекты элементов ПО, их интерфейсов и взаимосвязей, и **поведенческую нотацию**, которая представляет динамику работы системы и ее элементов,.
UML может использоваться как **эскиз** (неформальный подход), как **модель** (формальный, точный подход для детального описания) или как **исполняемый проект** (модель может быть скомпилирована),.

**6. Диаграммы UML – общая характеристика.**

Диаграммы UML группируют коллекции сущностей, представляющих интерес. Большинство диаграмм в своей основе являются графами. Диаграммы делятся на **диаграммы структуры** (например, классов, компонентов) и **диаграммы поведения** (например, деятельности, состояний). Количество типов диаграмм для конкретной модели приложения не является строго фиксированным и зависит от специфики проекта.

**7. Описание и оформление требований (спецификация). Анализ требований и стратегии выбора решения.**

**Инженерия требований** включает в себя несколько составляющих:
*   **Спецификация (Specification):** Формальное описание требований, спецификация требований к структуре ПО, функциям, качеству и документации, а также задание архитектуры и логики системы.
*   **Анализ (Analysis):** Изучение потребностей и целей пользователей; определение требований к системе исполнения, аппаратуре и ПО; устранение конфликтов между требованиями; определение приоритетов и принципов взаимодействия с окружением.

**8. Понятие репозитория проекта, структура проекта.**

Репозиторий упоминается как основной компонент инструментальных систем технологии программирования. Детальное определение или структура проекта в контексте репозитория в предоставленных лекциях не раскрываются.

**9. Виды, цели и уровни интеграции программных модулей.**

В предоставленных источниках отсутствует информация о видах, целях и уровнях интеграции программных модулей.

**10. Организация работы команды в системе контроля версий.**

Организация работы в системе контроля версий включает **ветвление**, **слияние** и **фиксацию изменений**.

**11. Отладка программных продуктов.**

**Отладка (debugging)** является одной из техник конструирования ПО. Отладка (наряду с кодированием и тестированием) также является частью стадии **Рабочий проект**.

**12. Инструменты отладки. Отладочные классы.**

В предоставленных источниках отсутствует детальная информация об инструментах отладки или отладочных классах.

**13. Инструментарии анализа качества программных продуктов в среде разработки.**

Для анализа качества ПО используются **метрики качества** — количественные показатели, позволяющие анализировать текущую ситуацию и прогнозировать качество конечного продукта.
При конструировании ПО используются следующие средства достижения качества и верификации:
*   **Стандарты кодирования** для снижения сложности и повышения читаемости.
*   **Обзоры кода** (code reviews), **модульное тестирование** и **автоматизация тестирования** для структуризации для проверок (выявление ошибок на ранних этапах),.
*   Средства коммуникации, такие как **системы документирования** и **диаграммы UML**, для учета изменений.

**14. Обработка исключительных ситуаций.**

Для обработки исключительных ситуаций (прерываний) без потери данных или выполненной работы может быть оправдано использование **исторических состояний** на диаграммах состояний.

**15. Методы и способы идентификации сбоев и ошибок.**

Идентификация ошибок и сбоев происходит в процессе **тестирования ПО**,. Методы тестирования включают:
*   **Тестирование «Белый ящик» (White box testing):** Структурное тестирование, проверяющее внутренние структуры и операции ПО (например, тестирование API, покрытие кода, статическое тестирование).
*   **Тестирование «Черный ящик» (Black box testing):** Тестирование функциональности, доступной конечному пользователю (например, анализ граничных значений, тестирование прецедентов).
*   **Тестирование «Серый ящик» (Gray box testing):** Тестирование с частичным знанием о внутренней структуре (например, тестирование интерфейсов компонентов системы).

**16. Базовые стратегии разработки ПС, достоинства и недостатки.**

Базовые модели жизненного цикла (ЖЦ) ПО, которые можно рассматривать как стратегии разработки:
*   **Каскадная модель (Waterfall):** Линейная, последовательная структура задач,.
    *   *Достоинства:* Строгая фиксация сроков и финансирования, удобное ведение отчетности, простота введения новых исполнителей.
    *   *Недостатки:* Отсутствие гибкости, результат виден только в конце, игнорирование меняющихся требований пользователей,.
*   **Инкрементная модель:** Разработка итерациями, каждая из которых завершается выпуском работоспособной версии, с применением процессов каскадной модели на каждой итерации,.
*   **Эволюционная модель:** Разработка с использованием функциональных прототипов, которые **эволюционируют** в элементы конечного продукта.
    *   *Недостатки:* Дополнительные затраты на разработку прототипов, недостаточный анализ системы (риск неоптимальной архитектуры), риск того, что заказчик примет прототип за финальный продукт.
*   **Спиральная модель:** Основная идея — **контроль риска** путем раннего тестирования наиболее сложных частей, с выбором модели процесса (каскадной, прототипирования) на каждой итерации,.
*   **Гибкая методология (Agile):** Цикличная работа, ориентированная на **гибкость** и быстрое реагирование на изменения,.
    *   *Достоинства:* Готовность к изменениям, регулярная обратная связь от заказчика (результат предоставляется на каждом цикле), ориентация на команду.
    *   *Недостатки:* Нет четкого планирования, требует сотрудничества заказчика, сложно изменить состав рабочей команды, риск неоптимальной архитектуры и снижения качества из-за множества изменений,.

**17. Основной компонент инструментальных систем технологии программирования – репозиторий.**

Репозиторий упоминается как основной компонент инструментальных систем. Более подробная информация в предоставленных источниках отсутствует.

**18. Понятие CASE – средства, их назначение и применение. Свойства современных CASE-средств, обеспечивающие поддержку процесса разработки программных продуктов.**

В предоставленных источниках отсутствует информация о понятии CASE-средств, их назначении, применении и свойствах.

**19. Математические модели, принципы их построения, виды моделей.**
**20. Понятие решения. Множество решений, оптимальное решение. Показатель эффективности решения.**
**21. Общий вид и основная задача линейного программирования. Симплекс-метод.**
**22. Транспортная задача. Методы нахождения начального решения. Метод потенциалов.**
**23. Общий вид задач нелинейного программирования. Графический метод решения задач.**
**24. Основные понятия динамического программирования.**
**25. Задача о нахождении кратчайших путей в графе и методы ее решения.**
**26. Задача о максимальном потоке и алгоритм Форда–Фалкерсона.**
**27. Математические имитационные модели исследования операций. Понятие допустимого и оптимального решения задач.**
**28. Понятие прогноза. Количественные методы прогнозирования. Качественные методы прогноза.**
**29. Основные понятия теории игр. Антагонистические матричные игры: чистые и смешанные стратегии.**

В предоставленных источниках отсутствует информация по вопросам 19-29, относящимся к математическим моделям, оптимизации и теории игр.

**30. Принципы проектирования программного обеспечения: модульность, повторное использование, расширяемость.**

Основные концепции проектирования ПО:
*   **Модульность:** Выделение автономных компонентов системы.
*   **Повторное использование (Reusability):** Использование архитектуры ПО является основой для повторного использования компонентов и решений.
*   **Расширяемость (Extensibility):** Архитектура ПО упрощает принятие решений, касающихся разработки, развертывания и поддержки ПО.

Дополнительные принципы: абстрагирование, уточнение, архитектура, структуризация и инкапсуляция.

**31. Понятие архитектуры программного обеспечения. Типовые архитектурные шаблоны.**

**Архитектура программного проекта** — это высокоуровневое представление структуры системы и спецификация ее компонентов и логики их взаимодействия. Это общая структура системы, связывающая все компоненты.
**Шаблон проектирования (Design pattern)** — это типовой конструктивный элемент программной системы, задающий взаимодействие нескольких компонентов, а также роли и сферы ответственности исполнителей,.
**Виды шаблонов:**
*   **Порождающие** (creational patterns): связаны с созданием объектов (например, фабрика, синглтон).
*   **Структурные** (structural patterns): определяют структуру композиции из нескольких объектов (например, мост, декоратор).
*   **Поведенческие** (behavioral patterns): определяют поведение объектов (например, итератор).

**32. Диаграмма вариантов использования (Use Case). Назначение, элементы, примеры.**

**Назначение:** Инструмент анализа требований, описывающий внешнее поведение системы, т.е. "Кто и для чего будет использовать нашу систему?".
**Элементы:**
*   **Актор (Actor):** Пользователь или внешняя система, взаимодействующая с системой (изображается человечком или пиктограммой).
*   **Вариант использования (Use Case):** Функция, которую система предоставляет актору (изображается овалом).
*   **Граница системы (System Boundary):** Прямоугольник, отделяющий внутренние функции системы от внешних акторов.
*   **Связи (Associations):** Линии, соединяющие акторов с вариантами использования.
*   **Отношения между вариантами использования:** **Include** (включение, один сценарий всегда включает другой) и **Extend** (расширение, один сценарий дополняет другой при условиях).

**33. Диаграмма классов. Основные элементы, отношения (ассоциация, агрегация, композиция, наследование).**

**Диаграмма классов** — диаграмма, предназначенная для представления модели статической структуры программной системы в терминологии классов ООП,.
**Основные элементы:**
*   **Класс (Class):** Прямоугольник, разделенный на секции: имя класса, атрибуты и операции,.
*   **Атрибут (Attribute):** Структурная характеристика или свойство, общее для всех объектов данного класса.
*   **Операция (Operation) / Метод:** Действие, которое может выполнить объект.

**Отношения:**
*   **Ассоциация (Association):** Представление произвольного отношения или взаимосвязи между классами.
*   **Обобщение (Generalization) / Наследование:** Отношение типа «Общее-Частное» (Класс-предок → Класс-потомок), обладающее свойством наследия свойств,.
*   **Агрегация (Aggregation):** Направленное отношение типа «Часть-Целое», где класс-контейнер включает в себя другие сущности в качестве составных частей,.
*   **Композиция (Composition):** Более сильная форма отношения «Часть-Целое», при которой с уничтожением класса-контейнера уничтожаются и все его составные части,.

**34. Диаграмма последовательностей (Sequence). Основные элементы, применение для анализа сценариев.**

**Диаграмма последовательностей** описывает взаимодействие объектов во времени. Она показывает, как система реализует конкретный вариант использования, отображая хронологический порядок обмена сообщениями.
**Основные элементы:**
*   **Объект (Object):** Участник сценария (например, «Пользователь», «Система»), имеющий линию жизни.
*   **Линия жизни (Lifeline):** Пунктирная вертикальная линия, показывающая существование объекта.
*   **Сообщения (Messages):** Горизонтальные стрелки, показывающие взаимодействие (сплошная — вызов, пунктирная — ответ).
*   **Активизация (Activation Bar):** Узкий прямоугольник на линии жизни, показывающий, когда объект выполняет операцию.

**Применение для анализа сценариев:** Позволяет визуализировать сценарий и увидеть, в каком порядке и какие объекты обмениваются данными,.

**35. Диаграмма состояний (State). События, переходы, состояния.**

**Диаграмма состояний** определяет все возможные состояния, в которых может находиться объект, и процесс смены состояний в результате наступления событий. Она моделирует поведение одного экземпляра класса (объекта).
**Основные элементы:**
*   **Состояние (State):** Прямоугольник со скругленными вершинами, может содержать внутренние действия (`entry`, `exit`, `do`),.
*   **Начальное состояние:** Закрашенный кружок, точка начала процесса.
*   **Конечное состояние (Final state):** Закрашенный кружок в окружности, точка завершения жизненного цикла объекта.
*   **Переход (Transition):** Перемещение из одного состояния в другое, изображается стрелкой.
*   **Событие (Event):** То, что вызывает переход из одного состояния в другое, размещается вдоль линии перехода,.

**36. Диаграмма деятельности (Activity). Параллельные процессы, ветвления, синхронизация.**

**Диаграмма деятельности** — поведенческая диаграмма UML, отображающая последовательность действий, включая ветвления, параллелизм, потоки управления и потоки данных.
**Элементы, связанные с логикой потока:**
*   **Ветвление / Решение (Decision node):** Ромб. Из одного входящего потока выходит два или более исходящих в зависимости от условия.
*   **Разделение (Fork node):** Толстая полоса, разделяющая один поток на два или более **параллельных потока**.
*   **Слияние (Join node):** Толстая полоса, объединяющая **параллельные потоки** обратно в один, обеспечивая **синхронизацию**,.
*   **Доли ответственности (Swimlanes):** Полосы, разделяющие диаграмму на зоны ответственности участников.

**37. Модели потоков данных (DFD). Элементы, уровни детализации, контекстная диаграмма.**

DFD-модели (Data Flow Diagrams) используются во внутреннем проектировании. В рамках перечня вопросов упоминаются следующие элементы: **потоки данных** (например, регистрация, конкурсная работа, отчет), **процессы** и **внешние сущности**. Детальное теоретическое описание элементов, уровней детализации и контекстной диаграммы в лекциях отсутствует.

**38. IDEF0 модели. Функции, входы, выходы, механизмы, управление.**

IDEF0-модели используются во внутреннем проектировании. В соответствии со структурой вопроса, IDEF0 описывает процесс или систему через:
*   **Функции**.
*   **Входы** (данные, необходимые для выполнения функции).
*   **Выходы** (результаты выполнения функции).
*   **Механизмы** (ресурсы/исполнители, выполняющие функцию, например, наставники или система управления конкурсами).
*   **Управление** (регламентирующие документы или правила).

**39. BPMN нотация. Основные элементы: события, задачи, шлюзы, пулы, потоки сообщений.**

BPMN (Business Process Model and Notation) — нотация для моделирования бизнес-процессов.
*   **Задачи (Tasks):** Простое действие, не подлежащее дальнейшей декомпозиции.
*   **События (Events):** Результат или причина выполнения процесса; обозначают начало (стартовое), конец (конечное) или промежуточные состояния. Различаются по типу триггера (Сообщение, Таймер, Ошибка, Сигнал и др.),.
*   **Шлюзы (Gateways):** Точки разветвления и слияния потоков управления. Типы: **Параллельный (AND, И)** для создания параллельных веток; **Эксклюзивный (XOR, исключающее ИЛИ)** для выбора одного альтернативного потока; **Не эксклюзивный (OR, не исключающее ИЛИ)**,.
*   **Пулы (Pools):** Содержимое пула представляет собой сам процесс. На диаграмме может быть только один развернутый пул.
*   **Дорожки (Lanes):** Используются для отображения организационных единиц — исполнителей (должности, подразделения, роли) внутри пула.
*   **Потоки сообщений (Message Flows):** Используются для отображения **межпроцессного взаимодействия** (между разными пулами).

**40. Применение BPMN для моделирования бизнес-процессов в организациях.**

BPMN используется для документирования, анализа и моделирования бизнес-процессов в организациях. Нотация позволяет четко отобразить ход выполнения процесса (**Потоки управления**), взаимодействие между различными участниками или системами (**Пулы и дорожки**), передачу информации между процессами (**Потоки сообщений**) и логику ветвления потоков (**Шлюзы**),,.

**41. ARIS нотация: элементы и цвета eEPC. Применение ARIS для оптимизации бизнес-процессов.**

ARIS eEPC (Extended Event Driven Process Chain — расширенная нотация описания цепочки процесса, управляемого событиями) — популярная методология для описания бизнес-процессов.
**Применение:** Позволяет наглядно и формально описать процесс, выявить причинно-следственные связи, действия пользователей и данные, что важно для анализа и оптимизации.
**Элементы и цвета eEPC:**
*   **События (Events):** **Розовые фигуры**. Состояние процесса, при котором должно выполниться действие; необходимое и достаточное условие для выполнения функции,.
*   **Функции (Functions) / Функциональные блоки:** **Зелёные элементы**. Действие или подпроцесс, выполняемый для получения результата и перевода системы из одного состояния в другое,.
*   **Субъект (Executor):** **Желтые овалы**. Обозначают исполнителей, владельцев или участников работы (должности, подразделения, роли).
*   **Ресурсы и результаты:** **Серые прямоугольники** (или похожие фигуры). Обозначают используемые и создаваемые ресурсы (документы, ТМЦ, информация, базы данных),.

**42. Управление версиями исходного кода: Git. Основные операции и ветвления.**

Git является системой управления версиями исходного кода. Основные операции при работе в системе контроля версий включают **ветвление**, **слияние** и **фиксацию изменений**.

**43. Модели жизненного цикла программного обеспечения: водопадная, итеративная, спиральная, agile.**

**Модель жизненного цикла** — это схема выполнения работ, обеспечивающая разработку, эксплуатацию и сопровождение программного продукта.
*   **Водопадная (Каскадная) модель:** Применение традиционного инженерного подхода, последовательное выполнение стадий: инженерия требований, проектирование, имплементация, тестирование, сопровождение.
*   **Инкрементная модель:** Разработка продукта итерациями, каждая из которых завершается выпуском работоспособной и осмысленной версии.
*   **Эволюционная модель:** Разработка с использованием прототипов, которые «эволюционируют» в элементы конечного продукта.
*   **Спиральная модель:** Циклическая модель, основная идея которой — **контроль риска** на каждой итерации, где выбирается подходящая модель процесса разработки,.
*   **Гибкая методология (Agile):** Основана на манифесте Agile (2001), фокусируется на итеративности, взаимодействии, работающем ПО и быстрой реакции на изменения.

**44. Понятие DevOps. Контейнеризация, CI/CD, автоматизация сборки и тестирования.**

Понятие DevOps и Контейнеризация в предоставленных источниках не определены.
Однако упоминаются связанные концепции:
*   **Непрерывная интеграция (CI):** Частая (несколько раз в день) автоматизированная сборка программного продукта, чтобы выявить интеграционные проблемы,.
*   **Автоматизированное модульное тестирование:** Немедленная проверка всех изменений, вносимых в код.

**45. Организация работы в системе контроля версий: ветвление, слияние, фиксация изменений.**

Организация работы в системе контроля версий включает **ветвление**, **слияние** и **фиксацию изменений**.

**46. Внешнее проектирование: разработка внешней спецификации, описание интерфейсов и взаимодействий.**

**Внешнее проектирование** — это разработка внешней спецификации, описание интерфейсов и взаимодействий.

**47. Внутреннее проектирование: создание схем, диаграмм UML, DFD, IDEF0 и других моделей.**

**Внутреннее проектирование** — это создание схем, диаграмм UML, DFD, IDEF0 и других моделей.

**48. Разработка модулей проекта: принципы модульного программирования, проектирование функций и классов.**

Принципы разработки модулей включают **модульность** (выделение автономных компонентов системы). Разработка модулей также включает проектирование функций и классов.

**49. Интеграция модулей в программное обеспечение: способы объединения, проверка совместимости и корректности.**

Интеграция модулей в ПО включает **способы объединения** модулей, а также **проверку их совместимости и корректности**.

**50. Модификация модулей проекта: причины изменений, методы обновления и оптимизации кода.**

**Модификация** является частью процесса **сопровождения ПО** (Software maintenance), которое включает внесение изменений при выявлении ошибок, адаптации к новой среде или улучшения характеристик.
**Категории сопровождения (причины изменений):**
*   **Корректировка:** Устранение выявленных ошибок.
*   **Адаптация:** Настройка продукта к изменившимся условиям эксплуатации.
*   **Предотвращение ошибок:** Устранение скрытых дефектов.
*   **Улучшение:** Увеличение продуктивности или повышение уровня сопровождения.
**Методы обновления и оптимизации кода:**
*   **Реинженерия:** Усовершенствование ПО путем реорганизации, реструктуризации или настройки параметров для новой среды исполнения.
*   **Рефакторинг кода:** Реорганизация кода программы для улучшения ее структуры, не изменяющая функциональность ПО.
*   **Реверсная инженерия:** Анализ ПО для создания его абстрактного представления,.
