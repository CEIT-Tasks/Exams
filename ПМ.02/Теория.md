### 1. Понятия требований к разработке ПО, классификация, уровни требований
**Требование к ПО** - это характеристика, позволяющая пользователю решать задачу или достигать цели, либо свойство системы, определенное контрактом, стандартом или спецификацией. 

**Классификация по видам:**
*   **Функциональные:** определяют назначение и функции системы.
*   **Нефункциональные:** условия исполнения, переносимости и доступа к данным.
*   **Требования к продукту и процессу:** режим работы, ограничения среды, принципы взаимодействия.
*   **Системные:** требования к системе в целом.
На уровне проектирования выделяют два вида: **условия заказчика** и **предложения команды** (требования проекта) для их выполнения.
---
### 2. Методологии и стандарты, регламентирующие работу с требованиями

**Стандарты**

* **ГОСТ 34.602-89**: Является фундаментальным стандартом для автоматизированных систем. Он четко определяет правила составления Технического задания (ТЗ), его структуру и содержание разделов.
* **ГОСТ 19.201-78**: Входит в комплекс Единой системы программной документации (ЕСПД). Регламентирует требования к ТЗ на программные изделия.
* **ГОСТ Р ИСО/МЭК 12207**: Адаптированный международный стандарт, описывающий процессы жизненного цикла программных средств, включая сбор, анализ и верификацию требований.

#### Международные стандарты и своды знаний
* **SWEBOK (Software Engineering Body of Knowledge)**: Международное руководство, классифицирующее знания в области программной инженерии. Оно выделяет инженерию требований как отдельную дисциплину с установленными этапами (извлечение, анализ, спецификация, проверка).
**Пять основных областей знаний SWEBOK**
	- Инженерия требования
	- Проектирование ПО
	- Конструирование ПО
	- Тестирование ПО
	- Сопровождение ПО

#### Методологические подходы
Формат работы с требованиями зависит от выбранной модели управления проектом:

* **Каскадная модель (Waterfall)**: Подразумевает создание исчерпывающего документа с требованиями в самом начале проекта. Изменения на более поздних этапах крайне затруднительны и дорогостоящи.
* **Гибкие методологии (Agile/Scrum)**: Вместо тяжеловесных документов используются «Пользовательские истории» (User Stories), фиксирующие потребности юзера. Требования уточняются и детализируются итеративно в течение всего проекта.
---
### 3. Методы организации работы в команде разработчиков
Существуют следующие подходы к организации работы в команде:
*   **Agile:** акцент на личностях и взаимодействии, самоорганизации и работе в команде. Основные принципы:
    - Деятельность в команде.
    - Готовый продукт важнее документации.
    - Приоритет личности и взаимодействия над процессами и инструментами,.
    - Многофункциональность каждого исполнителя (проектирование, кодирование, тестирование и т.д.).
    - Важность самоорганизации и взаимодействия между разработчиками.
*   **Парное программирование:** один пишет код, второй проверяет.
*   **Kanban:** использование доски с карточками для визуализации процесса и загрузки сотрудников.
*   **PRINCE2:** четкое разграничение обязанностей и деление работы на стадии.
---
### 4. Тестовое покрытие. Тестовый сценарий, тестовый пакет

**Тест** — это набор входных данных и прочих условий (например, характеристики операционной системы и оборудования), которые полностью определяют ход выполнения программы. Целью тестирования является локализация и устранение дефектов, соответствующих сбоям, обнаруженным с помощью этих тестов

#### Тестовое покрытие (Test Coverage)
**Тестовое покрытие** (Test Coverage) является одной из ключевых продуктовых метрик, которая отвечает на вопрос, насколько качествен сам продукт.

* **Покрытие требований**: оценивает, на все ли пункты технического задания написаны тесты.
* **Покрытие кода (Code Coverage)**: измеряет количество строк кода, условий или путей выполнения, которые были задействованы при запуске тестов. 
* **Покрытие интерфейса**: проверка всех кнопок, форм и путей навигации в пользовательском интерфейсе.

#### Тестовый сценарий (Test Case)
Тестовый сценарий (или тест-кейс) — это минимальная единица тестирования, представляющая собой набор условий и параметров для проверки конкретной функции системы. Хорошо структурированный сценарий включает:
1. **Предусловия**: начальное состояние системы (например, пользователь авторизован).
2. **Шаги воспроизведения**: последовательность действий (нажать кнопку, ввести текст).
3. **Тестовые данные**: конкретные значения, используемые при проверке.
4. **Ожидаемый результат**: описание того, как система должна отреагировать.
5. **Фактический результат**: фиксируется после прохождения теста для выявления расхождений.

#### Тестовый пакет (Test Suite)
Тестовый пакет (или набор тестов) — это логическая совокупность нескольких тестовых сценариев, объединенных по определенному признаку. 
* **Назначение**: пакеты создаются для удобства управления процессом тестирования. Например, «Пакет тестов для регистрации», «Пакет тестов безопасности» или «Пакет регрессионного тестирования».
* **Применение**: при интеграции новых модулей запускается соответствующий тестовый пакет, чтобы убедиться, что новые изменения не нарушили существующую логику и успешно взаимодействуют с остальной системой.
Использование этих элементов позволяет сделать процесс тестирования прозрачным, повторяемым и измеримым, что критически важно при сборке сложных программных систем из отдельных модулей.
---
### 5. Унифицированный язык моделирования UML. Нотации
**UML (Unified Modelling Languge)** - унифицированный язык моделирования, предназначенный для графического описания, визуализации и проектирования элементов программного обеспечения. Он является основным инструментом для создания логических моделей систем и их архитектуры.

#### Виды нотаций: 
*   **Структурная нотация:** ориентирована на представление статических аспектов системы — её компонентов, интерфейсов и взаимосвязей между ними. Примером может служить описание шаблонов проектирования, таких как «Декоратор»
*   **Поведенческая нотация:** описывает динамику работы системы, то есть то, как она и её элементы ведут себя во времени в ответ на внешние события

#### Три способа использования:
- **UML как эскиз** – это неформальный подход к UML, при котором используется схематическое изображение диаграмм, помогающее визуализировать программную систему. Для реализации этого подхода достаточно графического редактора с библиотекой прототипов.
- **UML как модель** – это более формальный и точный подход, при котором UML используется для подробного описания программной системы. UML модель активно поддерживается и становится важным поставляемым артефактом проекта. Этот подход требует использования инструментального средства моделирования.
- **UML как исполняемый проект** - UML модели могут использоваться как
язык программирования. Создается достаточно подробная UML модель, и
ИС может быть скомпилирована прямо из нее. При таком подходе необходим
UML инструмент, поддерживающий MDA (Model Driven Architecture –
архитектура, управляемая моделью).

#### Элементы нотации
| Элемент нотации | Изображение | Что означает | Где применяется |
| :--- | :--- | :--- | :--- |
| **Класс (Class)** | Прямоугольник с тремя секциями: 1. Имя класса; 2. Атрибуты; 3. Методы. Символы: `+` (public), `-` (private), `#` (protected). | Шаблон для создания объектов. Описывает данные (атрибуты) и поведение (методы). | Диаграмма классов, диаграмма объектов. |
| **Объект (Object)** | Прямоугольник с двумя секциями: 1. Имя объекта:Имя класса; 2. Значения атрибутов. | Конкретный экземпляр класса. | Диаграмма объектов, диаграмма последовательностей. |
| **Актор (Actor)** | Стилизованная фигурка человека (или прямоугольник с ключевым словом `<<actor>>`). | Внешняя сущность (пользователь, система), которая взаимодействует с нашей системой. | Диаграмма вариантов использования. |
| **Вариант использования (Use Case)** | Овал с названием внутри. | Цель или задача, которую актор хочет достичь с помощью системы. | Диаграмма вариантов использования. |
| **Состояние (State)** | Прямоугольник со скругленными углами с названием состояния внутри. | Устойчивая ситуация, в которой может находиться объект в ожидании какого-либо события. | Диаграмма состояний. |
| **Действие / Активность (Activity)** | Скругленный прямоугольник с названием действия внутри. | Выполняемая операция или шаг в процессе. | Диаграмма деятельности. |
| **Связь / Отношение (Relationship)** | Линии и стрелки разных видов. | Показывают, как элементы связаны между собой. | Все диаграммы. |

#### Виды связей (отношений)
| Тип связи | Нотация (стрелка) | Суть и пример | Ключевая фраза |
| :--- | :--- | :--- | :--- |
| **Ассоциация (Association)** | Обычная линия (может быть со стрелкой для указания направления чтения). | Факт связи между классами. Самый общий тип. | **"Связан с"**. Преподаватель — Студент. |
| **Агрегация (Aggregation)** | Линия с пустым ромбом со стороны целого. | Отношение "часть-целое", где часть может существовать отдельно от целого. Слабая связь. | **"Имеет"**. Библиотека — Книга. |
| **Композиция (Composition)** | Линия с закрашенным ромбом со стороны целого. | Строгое отношение "часть-целое", где часть не может существовать без целого. Сильная связь. | **"Содержит"**. Заказ — Позиция заказа. |
| **Наследование (Inheritance)** | Линия с пустым треугольником со стороны родителя. | Отношение "является". Дочерний класс наследует структуру и поведение родительского. | **"Является разновидностью"**. Студент — Человек. |
| **Реализация (Realization)** | Пунктирная линия с пустым треугольником со стороны интерфейса. | Класс реализует контракт, заданный интерфейсом. | **"Реализует"**. EmailService — INotificationSender. |
| **Зависимость (Dependency)** | Пунктирная линия со стрелкой. | Временная, слабая связь. Один класс использует другой в своем методе, но не хранит его как атрибут. | **"Использует"**. Генератор отчетов — Форматировщик PDF. |

---
### 6. Диаграммы UML – общая характеристика
**Диаграммы UML** представляют собой визуальные модели системы, которые в своей основе являются графами специального вида. В этих графах вершины отображаются в форме геометрических фигур (сущностей), а ребра или дуги — в виде линий (отношений или связей)
Согласно источникам, общая характеристика диаграмм включает следующие ключевые аспекты:
#### Классификация диаграмм
**Все канонические диаграммы UML делятся на две большие группы**
1. Диаграммы структуры: описывают статические аспекты системы. Сюда входят диаграммы классов, компонентов, объектов, развертывания, пакетов и композитной структуры
2. Диаграммы поведения: описывают динамику функционирования. В эту группу включены диаграммы деятельности, вариантов использования, состояний (конечного автомата) и диаграммы взаимодействия (последовательности, коммуникации, обзора взаимодействия и временные диаграммы)
Основные составляющие элементы
Любая диаграмма базируется на трех компонентах
- Сущности: ключевые абстракции (классы, интерфейсы, узлы и др.).
- Отношения: связи, объединяющие сущности (ассоциации, зависимости, обобщения).
- Сама диаграмма: логическая группировка сущностей и связей, представляющих интерес для разработчика
#### Принципы и правила построения
Для того чтобы диаграммы были эффективным инструментом проектирования, они должны соответствовать ряду характеристик:
- Завершенность и самодостаточность: каждая диаграмма должна быть законченным представлением фрагмента модели и быть понятной без дополнительных пояснительных текстов
- Концептуальное единство: все элементы на одной диаграмме должны находиться на одном уровне абстракции и детализации
- Явность информации: следует избегать значений «по умолчанию» (например, скрытой видимости атрибутов) и стремиться к явному указанию всех свойств
- Отсутствие противоречий: недопустимы замкнутые пути в отношениях композиции или наличие элементов с одинаковыми именами, но разными свойствами в одном пространстве имен
- Минимализм текста: визуализация наиболее эффективна, когда она содержит минимум пояснительного текста
- Иерархичность: модель системы на языке UML представляет собой пакет иерархически вложенных диаграмм, где сложные фрагменты могут детализироваться на дочерних схемах

---
### 7. Описание и оформление требований (спецификация). Анализ требований
Процесс работы с требованиями в программной инженерии (инженерия требований) включает в себя их извлечение, анализ, формальное описание (спецификацию) и последующую проверку
#### Анализ требований
Анализ требований — это этап, направленный на изучение потребностей и целей пользователей, а также определение условий функционирования системы
Основные задачи анализа включают:
- Изучение потребностей: выявление того, что именно пользователь хочет достичь с помощью ПО
- Определение окружения: установка требований к аппаратному обеспечению и системному программному окружению
- Разрешение конфликтов: устранение противоречий между требованиями разных заинтересованных сторон
- Приоритизация: определение очередности реализации функций
- Бизнес-анализ: классификация ожидаемых выгод по характеру воздействия (новые возможности, эффективность или отказ от лишних операций) и степени их определенности (от качественных до финансовых показателей)
Для сбора информации на этапе анализа часто используется метод интервью
Рекомендуется проводить встречи длительностью не более 1,5 часов, заранее подготовив список вопросов. Результатом таких встреч становится сводный протокол интервью, который согласуется с заказчиком
Описание и оформление требований (Спецификация)
Спецификация представляет собой формальное описание требований к программному продукту
В спецификацию включаются следующие аспекты:
- Функциональность: подробное описание функций и задач, которые должно решать ПО
- Структура и логика: задание архитектуры системы и правил обработки данных
- Качество и ограничения: требования к надежности, безопасности, а также ограничения среды исполнения и технического сопровождения
- Документация: требования к составу и содержанию программных документов
Оформление требований может регулироваться стандартами, такими как ГОСТ 19.106-78 (для ТЗ и программных документов)
Одним из инструментов интеграции требований заказчика в проект является «дом качества» (функция качества), который позволяет соотнести пожелания клиента с конкретными техническими предложениями команды
#### Проверка спецификаций
После оформления спецификация должна пройти процесс верификации (валидации)
На этом этапе требования проверяются на:
1. Однозначность (отсутствие двояких трактовок)
2. Непротиворечивость (требования не должны исключать друг друга)
3. Полноту и реализуемость (возможность выполнить требование в рамках бюджета и технологий)
Оценка корректности готового ПО в дальнейшем будет проводиться именно на основе степени его соответствия исходной спецификации и ТЗ
---
### 8. Понятие репозитория проекта и структура проекта

При разработке программного обеспечения репозиторий является фундаментом для управления кодом, а четкая структура проекта обеспечивает удобство интеграции модулей и поддержки системы.

#### Понятие репозитория (Repository)
**Репозиторий** — это специализированное хранилище, в котором содержатся все файлы проекта (исходный код, документация, ресурсы), а также полная история их изменений.
* **Централизованное хранение**: обеспечивает единую точку доступа ко всем активам проекта для всей команды.
* **Версионность**: репозиторий хранит каждый «снимок» (коммит) состояния проекта, что позволяет отследить автора изменений и при необходимости откатиться к любой предыдущей версии.
* **Типы репозиториев**:
    * **Локальный**: находится на компьютере разработчика.
    * **Удаленный**: размещается на сервере или облачном сервисе (GitHub, GitLab), выполняя роль центра синхронизации для команды.
* **Доступность**: репозитории могут быть публичными (открытыми для всех) или приватными (с ограниченным доступом).

#### Структура проекта
Структура проекта — это логическая организация папок и файлов внутри репозитория. Единый стандарт структуры помогает новым участникам быстро ориентироваться в проекте и автоматизировать процессы сборки.

**Типовые компоненты структуры проекта:**
* **`/src` (source)**: основная папка с исходным кодом программных модулей.
* **`/tests`**: тесты (юнит-тесты, интеграционные), проверяющие работоспособность кода.
* **`/docs`**: техническая документация, спецификации требований и руководства пользователя.
* **`/config/etc`**: конфигурационные файлы, настройки среды разработки и доступов.
* **`/lib`/vendor**: внешние библиотеки и зависимости, необходимые для работы модулей.
* **`/build/dist`**: папка для скомпилированных файлов и готовых артефактов сборки (обычно игнорируется системой контроля версий).
* **`README.md`**: главный файл с описанием проекта, инструкциями по установке и запуску.
* **`.gitignore`**: файл, указывающий системе контроля версий, какие папки и файлы (например, временные или секретные) не нужно отслеживать.
---
### 9. Виды, цели и уровни интеграции программных модулей
#### Цели интеграции:
**Интеграция программных модулей** — это процесс объединения отдельных программных компонентов в единую целостную систему и проверка их корректного взаимодействия.
 
#### Цели интеграции
Основная задача интеграции — убедиться, что модули, которые по отдельности работают правильно, сохраняют свою работоспособность при совместном функционировании. Ключевые цели включают:
* Проверку совместимости интерфейсов модулей.
* Выявление ошибок при передаче данных между компонентами.
* Проверку выполнения системных требований (производительность, надежность) в сборе.
* Подготовку продукта к системному тестированию.

#### Уровни интеграции
Интеграция может происходить на разных этапах детализации системы:
1. **Внутримодульная интеграция**: сборка внутренних компонентов одного крупного модуля.
2. **Межмодульная интеграция**: объединение нескольких модулей в функциональные группы (подсистемы).
3. **Системная интеграция**: сборка всех подсистем в конечный программный продукт и проверка его взаимодействия с внешним окружением (БД, сторонние API).

#### Методы и виды интеграции:
  - Непрерывная интеграция (Continuous Integration): метод, предполагающий частую (несколько раз в день) автоматизированную сборку программного продукта.
  - Интеграционное тестирование: процесс проверки взаимодействия между компонентами, который следует за модульным тестированием и предшествует системному.

#### Процесс интеграции в ЖЦ:
  - Интеграция входит в основной процесс «Разработка» согласно стандарту ISO 12207 и включает в себя проверку совместимости и корректности модулей.
  - Для обеспечения взаимодействия модулей могут использоваться внешние стандарты, такие как COM или CORBA.
#### Виды (стратегии) интеграции
Существует несколько классических подходов к процессу сборки:

* **Интеграция «сверху вниз» (Top-down)**:
    * Сборка начинается с управляющих модулей верхнего уровня.
    * Недостающие модули нижнего уровня заменяются «заглушками» (stubs) — временным кодом, который имитирует работу реального компонента.
    * Плюс: позволяет рано увидеть архитектуру системы.

* **Интеграция «снизу вверх» (Bottom-up)**:
    * Сначала собираются и тестируются низкоуровневые модули.
    * Для их запуска используются «драйверы» — специальные надстройки, вызывающие функции модулей.
    * Плюс: проще тестировать конкретные вычислительные алгоритмы.

* **Метод «Большого взрыва» (Big Bang)**:
    * Все модули собираются в систему одновременно, после чего начинается тестирование.
    * Минус: крайне сложно локализовать ошибку, так как она может быть в любом из компонентов или интерфейсов.

* **Сэндвич-интеграция (комбинированная)**:
    * Сочетает подходы «сверху вниз» и «снизу вверх», позволяя одновременно вести разработку интерфейса и базовой логики.
---
### 10. Организация работы команды в системе контроля версий

Эффективная разработка в команде невозможна без использования систем контроля версий (VCS), таких как Git. Организация процесса направлена на минимизацию конфликтов в коде и обеспечение стабильности продукта при одновременной работе нескольких специалистов.

#### 1. Основные концепции командной работы
Работа строится на взаимодействии локальных репозиториев разработчиков и центрального удаленного репозитория (например, на платформе GitLab или GitHub):
* **Клонирование**: создание локальной копии проекта.
* **Синхронизация**: регулярное получение обновлений от коллег (`fetch`/`pull`) и отправка своих наработок (`push`).

#### 2. Модели ветвления (Workflow)
Для координации действий команды используются определенные правила создания и слияния веток. Самые популярные модели:

* **Git Flow**:
    * `main` (или `master`): содержит только стабильный, готовый к выпуску код.
    * `develop`: основная ветка разработки, куда сливаются новые функции.
    * `feature`: временные ветки для реализации конкретных задач.
    * `hotfix`: ветки для срочного исправления ошибок в рабочей версии.
* **GitHub Flow**: более простая модель, где все изменения вносятся в ветки функций, которые после тестирования сразу сливаются в `main`.

#### 3. Процесс внесения изменений
Типичный цикл работы разработчика в команде выглядит следующим образом:
1. Создание отдельной ветки под конкретную задачу.
2. Локальная разработка и фиксация изменений (коммиты).
3. Отправка ветки в удаленный репозиторий.
4. Создание **запроса на слияние (Merge Request / Pull Request)**.

#### 4. Командное рецензирование и проверка качества
Интеграция программных модулей в общую кодовую базу происходит только после прохождения контроля:
* **Code Review**: коллеги изучают предложенный код, оставляют замечания и советы по улучшению.
* **Автоматизированное тестирование (CI)**: при создании запроса на слияние автоматически запускаются тесты, проверяющие, не нарушила ли новая функция работу остальной системы.

#### 5. Разрешение конфликтов
Когда два разработчика одновременно меняют один и тот же участок кода, возникает конфликт слияния. В команде это решается путем ручного сопоставления версий. Ответственность за разрешение конфликта обычно лежит на авторе последних изменений, который должен убедиться, что логика коллег не была удалена или повреждена.

Такой подход позволяет поддерживать высокую скорость разработки и гарантирует, что в основной код попадают только проверенные и согласованные модули.

---
### 11. Отладка программных продуктов

Отладка — это этап разработки программного обеспечения, на котором происходит обнаружение, локализация и устранение ошибок (багов), выявленных в процессе тестирования или эксплуатации системы.

* **Суть процесса**: В отличие от тестирования, которое лишь констатирует наличие ошибки, отладка направлена на выяснение её причины и поиск способа исправления кода.
* **Этапы отладки**:
    1.  **Воспроизведение**: создание условий, при которых ошибка проявляется стабильно.
    2.  **Локализация**: определение конкретного участка кода (модуля, функции, строки), вызывающего некорректное поведение.
    3.  **Исправление**: изменение исходного кода для устранения дефекта.
    4.  **Проверка**: подтверждение того, что ошибка исчезла и не возникли новые (регрессионное тестирование).

---

### 12. Инструменты отладки. Отладочные классы

Эффективная интеграция модулей требует использования специальных программных средств, автоматизирующих поиск ошибок.

* **Инструменты отладки (Дебаггеры)**:
    * **Точки останова (Breakpoints)**: позволяют приостановить выполнение программы на определенной строке для проверки состояния памяти и значений переменных.
    * **Пошаговое выполнение (Stepping)**: выполнение кода по одной инструкции («шаг с заходом в функцию», «шаг через функцию»).
    * **Просмотр переменных (Watch)**: мониторинг изменения значений конкретных объектов в реальном времени.

* **Отладочные классы**:
    * Это вспомогательный программный код, который используется только на этапе разработки.
    * **Функции**: логирование промежуточных состояний, проверка инвариантов (условий, которые всегда должны быть истинны) и имитация ответов от модулей, которые еще не интегрированы.
    * Обычно такие классы исключаются из финальной сборки или отключаются с помощью флагов компиляции.

---

### 13. Инструментарии анализа качества ПО в среде разработки

Для обеспечения высокого качества программного продукта применяются инструменты автоматического анализа кода, встроенные в IDE или внешние сервисы.

* **Статический анализ (Static Analysis)**:
    * Проверка кода без его фактического запуска.
    * **Линтеры (Linters)**: проверяют соблюдение стандартов оформления кода и выявляют потенциально опасные конструкции.
    * Инструменты вроде **SonarQube** ищут дублирование кода, уязвимости и «код с запашком» (неэффективные решения).
* **Динамический анализ (Dynamic Analysis)**:
    * Анализ программы во время её выполнения.
    * **Профилировщики (Profilers)**: измеряют потребление памяти, нагрузку на процессор и время выполнения отдельных функций.
    * Помогают найти утечки памяти и «узкие места», замедляющие работу системы.

---

### 14. Обработка исключительных ситуаций

Исключительная ситуация (исключение) — это непредвиденное событие, возникающее во время выполнения программы (например, отсутствие файла, деление на ноль, обрыв сетевого соединения), которое нарушает нормальный ход инструкций.

* **Механизм обработки**:
    * **Try**: блок кода, в котором может возникнуть ошибка.
    * **Catch**: блок, перехватывающий исключение и содержащий логику по его обработке (например, вывод сообщения пользователю или запись в лог).
    * **Finally**: блок, который выполняется в любом случае (обычно используется для освобождения ресурсов, например, закрытия файлов).
    * **Throw**: принудительная генерация исключения, если программа зашла в недопустимое состояние.

* **Значение при интеграции**: Надежная обработка исключений гарантирует, что ошибка в одном модуле не приведет к аварийному завершению всей системы, а будет корректно обработана, сохраняя работоспособность других компонентов.
---
### 15. Методы и способы идентификации сбоев и ошибок

#### Основные методы идентификации

* **Логирование (Logging)**:
    * Основной метод, заключающийся в записи событий, происходящих в системе, в специальные текстовые файлы (логи).
    * Анализ логов позволяет отследить последовательность действий, предшествовавших сбою, и увидеть сообщения об ошибках, сгенерированные самой системой или средой выполнения.

* **Трассировка (Tracing)**:
    * Метод отслеживания пути выполнения программы и значений переменных в динамике. 
    * Трассировка помогает визуализировать поток данных между модулями и выявить точку, где данные принимают недопустимые значения.

* **Анализ дампов памяти (Core Dumps)**:
    * При критическом сбое системы (крахе) создается снимок состояния оперативной памяти.
    * Анализ дампа позволяет разработчикам увидеть состояние всех объектов и стека вызовов в момент падения программы.

#### Отличия сбоев от ошибок 
#### Способы локализации ошибок

* **Метод «Разделяй и властвуй»**:
    * Система последовательно отключает или изолирует модули, чтобы определить, какой из них вызывает сбой. Если без определенного модуля система работает стабильно, ошибка локализована в нем.

* **Использование точек останова (Breakpoints)**:
    * Разработчик намеренно останавливает выполнение программы в ключевых точках, чтобы проверить, соответствуют ли текущие данные ожидаемым.

* **Удаленная отладка (Remote Debugging)**:
    * Применяется, когда ошибка проявляется только на сервере или стороне клиента, но не воспроизводится на компьютере разработчика. Инструменты отладки подключаются к работающему экземпляру приложения по сети.

* **Мониторинг исключений**:
    * Использование систем сбора ошибок (например, Sentry), которые автоматически перехватывают необработанные исключения и отправляют подробный отчет разработчикам с контекстом возникновения ошибки.
---

### 16. Базовые стратегии разработки ПС
#### 1. Каскадная модель (Waterfall)
Это классический инженерный подход, где все задачи идут последовательно и линейно, как поток воды.

**Плюсы:**
  - Строгая фиксация сроков и объемов финансирования
  - Простота введения в курс новых исполнителей благодаря заранее поставленным задачам 5
  - Удобное ведение документации и отчетности; не требует постоянного вовлечения заказчика

**Минусы:**
  - Отсутствие гибкости: при изменении обстоятельств планирование нужно начинать с начала
  - Результат виден только в самом конце проекта
  - Большой временной разрыв между внесением ошибки и её обнаружением

**Когда применять:** 
Для комплексных систем с жесткими требованиями, где стабильность важнее затрат на разработку.

#### 2. Инкрементная модель
Разработка продукта происходит итерациями, каждая из которых завершается выпуском работоспособной версии системы с наращиванием функций.

**Плюсы:**
  - Обеспечивает быструю реализацию ключевых возможностей системы
  - Возможность поэтапного финансирования отдельных частей продукта
**Минусы:**
  - Требования остаются фиксированными на протяжении всего процесса разработки (сложно вносить изменения в уже утверждённый план инкремента)


#### 3. Эволюционная модель
Основана на создании функциональных прототипов, которые постепенно превращаются в конечный продукт.

**Плюсы:**
  - Позволяет уточнить требования пользователей через "ощутимые" прототипы
  - Активное использование средств автоматизации и актуальных средств разработки
**Минусы:**
  - Риск получения неоптимальной архитектуры из-за недостаточно глубокого предварительного анализа системы
  - Заказчик может принять промежуточный прототип за финальный продукт

#### 4. Спиральная модель
Акцентирует внимание на минимизации рисков путем их анализа на каждой итерации/

**Плюсы:**
    - Раннее тестирование наиболее сложных и рискованных частей ПО
    - Гибкость в выборе модели разработки (каскадная или прототипирование) для каждой отдельной итерации
**Минусы:**
    - Сложность определения момента перехода на новую итерацию
**Когда применять:** в дорогостоящих проектах, где риски критичны

#### 5. Гибкая методология (Agile)
Ориентирована на личности, взаимодействие и работающий продукт, а не на жесткие процессы и документацию.

**Плюсы:**
    - Готовность к любым изменениям требований на любом этапе
    - Постоянная обратная связь от заказчика после каждого цикла
    - Высокая мотивация команды за счет самоорганизации
**Минусы:**
    - Отсутствие четкого планирования на длительный срок
    - Риск снижения качества из-за частых изменений без достаточного тестирования архитектуры
    - Требует постоянного присутствия и участия представителя заказчика
#### Другие специализированные подходы:
  - Kanban: визуализирует загрузку сотрудников через доски с карточками. Плюс: наглядность. Минус: не подходит для долгосрочного планирования
  - PRINCE2: жесткая каскадная система с четким делением на роли. Плюс: эффективность в крупных проектах. Минус: громоздкость для малых компаний
---
### 17. Основной компонент инструментальных систем технологии программирования — репозиторий

В контексте инструментальных систем (CASE-средств) **репозиторий** представляет собой специализированную базу данных, которая служит единым хранилищем всей информации о проекте на протяжении его жизненного цикла.

* **Назначение**: Обеспечение целостности, непротиворечивости и доступности данных для всех участников проекта и используемых ими программных инструментов.
* **Состав хранимой информации**:
    * Проектные спецификации и требования.
    * Графические модели и диаграммы (UML, ER-диаграммы).
    * Исходный код и объектные модули.
    * Документация и отчеты.
    * Сведения об истории изменений и связях между объектами.
* **Роль в интеграции**: Репозиторий позволяет отслеживать взаимозависимости между программными модулями. Если в один модуль вносятся изменения, система через репозиторий может указать, какие другие компоненты или документы требуют корректировки.

---

### 18. Понятие CASE-средства, их назначение и применение

**CASE-средства** (Computer-Aided Software Engineering) — это комплекс программных инструментов, автоматизирующих процессы проектирования, разработки, тестирования и сопровождения программного обеспечения.

#### Назначение и применение
CASE-средства используются для перевода процесса разработки на индустриальную основу. Они применяются для:
* Проектирования архитектуры сложных систем.
* Автоматической генерации программного кода на основе созданных моделей.
* Визуализации бизнес-процессов и потоков данных.
* Поддержания актуальности документации в автоматическом режиме.

#### Свойства современных CASE-средств
Современные инструменты обладают рядом свойств, которые критически важны для профессиональной разработки:

1.  **Графическое моделирование**: Наличие удобных редакторов для создания UML, BPMN или IDEF-диаграмм, что упрощает понимание структуры системы.
2.  **Прямое и обратное проектирование (Forward/Reverse Engineering)**:
    * *Прямое*: генерация каркаса кода из визуальной модели.
    * *Обратное*: автоматическое построение диаграмм на основе уже написанного исходного кода.
3.  **Совместная работа**: Поддержка многопользовательского доступа через единый репозиторий с контролем прав и версионности.
4.  **Проверка корректности (Checkability)**: Автоматический поиск логических ошибок в архитектуре (например, наличие «тупиковых» процессов в диаграммах).
5.  **Масштабируемость**: Способность работать с проектами, содержащими тысячи классов или модулей, без потери производительности.
6.  **Интеграция с другими инструментами**: Возможность экспорта данных в системы контроля версий (Git), таск-трекеры или среды разработки (IDE).

Использование CASE-средств позволяет значительно сократить количество ошибок на этапе проектирования и ускорить процесс интеграции программных модулей в единую систему.

---
### 19. Математические модели, принципы их построения, виды моделей

**Математическая модель** — это упрощенное описание реальности, выраженное с помощью математических символов (уравнений, неравенств, функций), которое отражает ключевые свойства изучаемого объекта или процесса.

* **Принципы построения**:
    * **Адекватность**: модель должна соответствовать реальному процессу в существенных чертах.
    * **Простота**: исключение второстепенных факторов для облегчения расчетов.
    * **Полнота**: учет всех параметров, критически влияющих на результат.
    * **Устойчивость**: малые изменения исходных данных не должны приводить к резким скачкам результата.
* **Виды моделей**:
    * **Детерминированные**: результат однозначно определяется входными данными.
    * **Стохастические (вероятностные)**: учитывают фактор случайности.
    * **Линейные и нелинейные**: в зависимости от вида функций, описывающих систему.
    * **Дискретные и непрерывные**: в зависимости от характера изменения переменных.
---
### 20. Понятие решения. Множество решений, оптимальное решение. Показатель эффективности решения

В задачах исследования операций и интеграции систем выбор наилучшего варианта основывается на математическом анализе.

* **Решение**: набор значений управляемых переменных, который удовлетворяет всем условиям (ограничениям) задачи. Такое решение также называют **допустимым**.
* **Множество решений**: совокупность всех возможных допустимых решений, образующих область поиска.
* **Оптимальное решение**: допустимое решение, которое обеспечивает наилучшее (максимальное или минимальное) значение целевой функции.
* **Показатель эффективности (Критерий оптимальности)**: численная величина, позволяющая сравнивать решения между собой (например, минимальная стоимость разработки, максимальное быстродействие модуля).
---
### 21. Общий вид и основная задача линейного программирования. Симплекс-метод

**Линейное программирование (ЛП)** — метод оптимизации систем, где целевая функция и ограничения линейны.

* **Общий вид задачи**:
    1.  Целевая функция: $Z = c_1x_1 + c_2x_2 + ... + c_nx_n \to max (min)$.
    2.  Система ограничений: линейные равенства или неравенства (например, затраты ресурсов не должны превышать запасы).
    3.  Условие неотрицательности: $x_i \ge 0$.
* **Основная задача**: распределить ограниченные ресурсы так, чтобы получить максимальный эффект.
* **Симплекс-метод**: универсальный алгебраический алгоритм решения задач ЛП.
    * Суть: последовательный переход от одной вершины многогранника допустимых решений к другой, соседней, в которой значение целевой функции лучше. Процесс повторяется, пока не будет найдена точка максимума или минимума.
---

### 22. Транспортная задача. Методы нахождения начального решения. Метод потенциалов

**Транспортная задача** — специфический вид задачи ЛП, направленный на минимизацию затрат при перевозке однородного груза от поставщиков к потребителям.

* **Нахождение начального (опорного) решения**:
    * **Метод северо-западного угла**: формальное заполнение таблицы с верхнего левого угла. Простой, но часто дает неэффективное решение.
    * **Метод минимального элемента**: заполнение клеток с наименьшей стоимостью перевозки. Более эффективен для старта.
* **Метод потенциалов**:
    * Это метод проверки полученного решения на оптимальность. Каждому поставщику и потребителю присваивается числовой коэффициент (потенциал). Если для всех пустых клеток выполняется определенное условие (косвенные издержки не превышают реальные), решение оптимально. В противном случае производится перераспределение груза по циклу пересчета.
---
### 23. Общий вид задач нелинейного программирования. Графический метод решения задач

Задачи нелинейного программирования (НЛП) возникают, когда зависимости между параметрами системы нельзя описать простыми линейными функциями. В программировании это часто связано с оптимизацией ресурсов при нелинейном росте затрат или сложности алгоритмов.

#### Общий вид задачи НЛП
Задача нелинейного программирования заключается в нахождении экстремума (максимума или минимума) целевой функции при соблюдении ряда ограничений. В отличие от линейного программирования, здесь хотя бы одна из функций (целевая или функции в системе ограничений) является нелинейной.

Математически это записывается так:
1.  **Целевая функция**: $f(x_1, x_2, ..., x_n) \to max (min)$.
2.  **Ограничения**: $g_i(x_1, x_2, ..., x_n) \le b_i$ (или $\ge, =$), где функции $f$ или $g_i$ могут содержать переменные в квадрате, под корнем, логарифмы и т.д.
3.  **Условие области**: $x \in X$.

#### Графический метод решения
Графический метод наиболее нагляден для задач с двумя переменными ($x_1$ и $x_2$). Он позволяет визуализировать область поиска и найти оптимальную точку.

**Этапы решения:**
1.  **Построение области допустимых решений (ОДР)**:
    * Каждое ограничение-неравенство изображается на плоскости. 
    * Линейное ограничение — это прямая, нелинейное — кривая (окружность, парабола, гипербола).
    * Пересечение всех областей дает ОДР. В НЛП эта область может быть вогнутой или несвязной.
2.  **Построение линий уровня**:
    * Строятся линии, в каждой точке которых целевая функция принимает постоянное значение $f(x_1, x_2) = C$.
3.  **Поиск экстремума**:
    * Определяется направление возрастания (или убывания) функции (градиент).
    * Линия уровня перемещается в этом направлении до тех пор, пока она не коснется границы ОДР в последней (для максимума) или первой (для минимума) точке.

**Особенности**:
* В линейных задачах оптимум всегда находится в вершине многогранника. В нелинейных — оптимальная точка может находиться в любой точке границы или даже внутри области.
* Если область допустимых решений не является выпуклой, метод может найти «локальный» минимум, который не будет являться наилучшим для всей задачи (глобальным).

### 24. Основные понятия динамического программирования

**Динамическое программирование (ДП)** — это метод решения сложных задач путем их разбиения на более мелкие и простые подзадачи. Он особенно эффективен, когда подзадачи перекрываются (результаты одних и тех же расчетов требуются многократно).

* **Принцип оптимальности Беллмана**: Оптимальное решение всей задачи содержит в себе оптимальные решения всех её подзадач.
* **Мемоизация (Memoization)**: Сохранение результатов выполнения подзадач в специальной таблице (памяти), чтобы не вычислять их заново при повторном обращении.
* **Подходы**: 
    * *Сверху вниз (Top-down)*: рекурсивное решение с сохранением результатов.
    * *Снизу вверх (Bottom-up)*: итеративное заполнение таблицы от простых случаев к сложным.
* **Примеры**: поиск кратчайшего пути в графе, задача о рюкзаке, вычисление чисел Фибоначчи.



---

### 25. Задача о нахождении кратчайших путей в графе и методы ее решения

Задача заключается в поиске пути между двумя вершинами графа (или от одной до всех остальных), сумма весов ребер которого минимальна.

**Основные алгоритмы:**
1.  **Алгоритм Дейкстры**: Находит кратчайшие пути от одной вершины до всех остальных. Работает только в графах без ребер с отрицательным весом.
2.  **Алгоритм Беллмана-Форда**: Позволяет находить кратчайшие пути даже в графах с отрицательными весами ребер и способен обнаруживать циклы отрицательного веса.
3.  **Алгоритм Флойда-Уоршелла**: Находит кратчайшие расстояния между всеми парами вершин графа.



---

### 26. Задача о максимальном потоке и алгоритм Форда–Фалкерсона

Задача состоит в определении максимального объема «груза» (трафика, жидкости), который можно передать из источника (Source) в сток (Sink) через сеть с ограниченной пропускной способностью ребер.

* **Алгоритм Форда–Фалкерсона**:
    1.  Находим любой увеличивающий путь от источника к стоку, где пропускная способность еще не исчерпана.
    2.  Увеличиваем поток вдоль этого пути на максимально возможную величину (минимальный остаток на ребрах пути).
    3.  Строим остаточную сеть и повторяем процесс, пока пути существуют.
* **Теорема о максимальном потоке и минимальном разрезе**: Величина максимального потока в сети равна минимальной пропускной способности разреза, отделяющего источник от стока.
---
### 27. Математические имитационные модели исследования операций. Понятие допустимого и оптимального решения задач

**Имитационное моделирование** — это метод исследования систем, при котором строится алгоритм, воспроизводящий поведение системы во времени. В отличие от аналитических моделей, здесь не ищется формула, а проводится «цифровой эксперимент».

* **Назначение**: Изучение систем с высоким уровнем неопределенности и сложными внутренними связями (например, работа склада, сетевой трафик).
* **Допустимое решение**: Любой набор параметров управления, который удовлетворяет всем заданным ограничениям (ресурсным, временным, техническим).
* **Оптимальное решение**: Допустимое решение, которое обеспечивает наилучшее значение выбранного критерия эффективности (целевой функции).
---
### 28. Понятие прогноза. Методы прогнозирования

**Прогноз** — это вероятностное суждение о будущем состоянии объекта или системы на основе анализа данных.

* **Количественные методы**: Основаны на математических расчетах и статистике.
    * *Экстраполяция тренда*: продление тенденций прошлого в будущее.
    * *Регрессионный анализ*: поиск зависимости между прогнозируемым параметром и влияющими на него факторами.
* **Качественные методы**: Основаны на экспертных оценках и интуиции.
    * *Метод Дельфи*: многоуровневый опрос группы экспертов до достижения согласия.
    * *Метод сценариев*: описание нескольких вариантов развития событий (оптимистичный, пессимистичный).

---

### 29. Основные понятия теории игр. Антагонистические матричные игры

**Теория игр** — математический метод изучения стратегий в ситуациях, где результат зависит от действий нескольких участников с разными интересами.

* **Антагонистическая игра (игра с нулевой суммой)**: Игра двух участников, в которой выигрыш одного в точности равен проигрышу другого.
* **Матричная игра**: Игра, правила которой задаются платежной матрицей, где строки — стратегии игрока А, столбцы — игрока Б.
* **Чистые стратегии**: Выбор одного конкретного действия. Если в матрице есть «седловая точка» (минимум в строке совпадает с максимумом в столбце), оптимальное решение лежит в чистых стратегиях.
* **Смешанные стратегии**: Если седловой точки нет, игроки применяют свои стратегии случайно с определенными вероятностями. Это позволяет достичь среднего оптимального результата.
---
### 30. Принципы проектирования ПО
*   **Модульность:** выделение автономных компонентов системы.
*   **Повторное использование:** использование архитектуры как основы для применения готовых решений.
*   **Расширяемость (Ожидание изменений):** проектирование кода с учетом будущих дополнений.

### 31. Понятие архитектуры ПО. Типовые шаблоны
**Архитектура** — высокоуровневое представление структуры системы и ее компонентов.
**Шаблоны проектирования:**
*   **Порождающие:** (фабрика, синглтон) — создание объектов.
*   **Структурные:** (мост, декоратор) — композиция объектов.
*   **Поведенческие:** (итератор) — взаимодействие объектов.
---
### 32. Диаграмма вариантов использования (Use Case)
Назначение: Является основным инструментом анализа требований и описывает внешнее поведение системы, отвечая на вопрос: «Кто и для чего будет использовать систему?»
. Основные элементы:
- Актор (Actor): Роль пользователя или внешней системы, взаимодействующей с ПО (обозначается «человечком»)
- Вариант использования (Use Case): Конкретная функция системы (овал с названием-глаголом)
- Связи: Ассоциации между акторами и функциями, а также отношения Include (обязательное включение сценария) и Extend (дополнение сценария при условии)
- Граница системы: Прямоугольник, отделяющий внутренние функции от внешних участников
. Примеры: «Оформить заказ», «Авторизоваться», «Посмотреть товары»

---
### 33. Диаграмма классов (Class Diagram)
Назначение: Описывает статическую структуру системы в терминах классов объектно-ориентированного программирования
. Это основная логическая модель системы
. Основные элементы:
- Класс: Содержит имя, атрибуты (свойства) и операции (методы)
- Видимость: Определяет доступность элементов (+ public, - private, # protected, ~ package)
. Типы отношений:
- Ассоциация: Произвольная связь между экземплярами классов
- Агрегация: Отношение «часть-целое», где части могут существовать независимо
- Композиция: Сильная форма «часть-целое», при которой части уничтожаются вместе с целым
- Обобщение (Наследование): Отношение «предок-потомок», позволяющее наследовать свойства родительского класса

---
### 34. Диаграмма последовательностей (Sequence Diagram)
Назначение: Описывает взаимодействие объектов во времени, визуализируя хронологический порядок обмена сообщениями в конкретном сценарии использования
**Основные элементы:**
- Объект и линия жизни: Линия жизни (пунктир) показывает время существования объекта в сценарии
- Сообщения: Горизонтальные стрелки (сплошная — вызов/запрос, пунктирная — ответ/возврат данных)
- Активизация: Узкий прямоугольник на линии жизни, показывающий период выполнения операции объектом

---
### 35. Диаграмма состояний (State Diagram)
#### Назначение
Описывает жизненный цикл одного конкретного объекта и процесс смены его состояний в ответ на внешние события
**Основные элементы:**
- Состояние: Прямоугольник со скругленными углами. Может содержать внутренние действия: entry (вход), exit (выход), do (деятельность в процессе нахождения в состоянии)
- Переход: Перемещение объекта из одного состояния в другое (стрелка)
- Событие (Триггер): Внешнее воздействие, вызывающее переход
- Начальное и конечное состояния: Точки входа (черный кружок) и выхода (кружок в окружности) в жизненном цикле

---
### 36. Диаграмма деятельности (Activity Diagram)
Назначение: Описывает логику процесса или деятельности как последовательность действий с учетом ветвлений и параллельного выполнения
. Основные элементы:
- Действие: Конкретная задача (прямоугольник с закругленными углами)
- Ветвление и объединение: Ромб (Decision node), направляющий поток по разным веткам в зависимости от условий
- Синхронизация и параллелизм:
    - Разделение (Fork): Одна входящая стрелка и несколько исходящих (начало параллельных процессов)
    - Слияние (Join): Несколько входящих стрелок объединяются в одну (синхронизация параллельных потоков перед следующим шагом)
- Дорожки (Swimlanes): Зоны, разделяющие ответственность участников (ролей) за конкретные действия
---
### 37. Модели потоков данных (DFD). Элементы, уровни детализации, контекстная диаграмма

**DFD (Data Flow Diagram)** используется для описания того, как данные перемещаются через систему, где они хранятся и как преобразуются процессами.

* **Основные элементы**:
    * **Процесс (круг или прямоугольник)**: трансформация входящих данных в исходящие.
    * **Внешняя сущность (квадрат)**: источник или получатель данных вне системы.
    * **Поток данных (стрелка)**: путь передачи информации.
    * **Накопитель данных (две параллельные линии)**: место хранения информации (база данных, файл).
* **Уровни детализации**:
    * **Контекстная диаграмма (Уровень 0)**: представляет систему как единый процесс, показывая только её связи с внешним миром.
    * **Декомпозиция**: разбиение основного процесса на более детальные диаграммы (уровень 1, 2 и т.д.) для уточнения внутренней логики.
---
### 38. IDEF0 модели. Функции, входы, выходы, механизмы, управление

**IDEF0** — это стандарт функционального моделирования, предназначенный для описания бизнес-процессов и функций системы.

* **Функциональный блок**: отображается в виде прямоугольника, внутри которого пишется глагол (действие).
* **Стрелки (Интерфейсы)**:
    * **Вход (левая сторона)**: сырье или данные, которые преобразуются процессом.
    * **Выход (правая сторона)**: результат выполнения функции.
    * **Управление (верхняя сторона)**: правила, стандарты, регламенты и законы, которыми руководствуется процесс.
    * **Механизмы (нижняя сторона)**: ресурсы, необходимые для выполнения работы (персонал, оборудование, программное обеспечение).
---
### 39. BPMN нотация. Основные элементы

**BPMN (Business Process Model and Notation)** — современный стандарт моделирования бизнес-процессов, понятный как аналитикам, так и разработчикам.

* **Объекты потока**:
    * **События (круги)**: начало, окончание или промежуточное состояние процесса.
    * **Задачи (прямоугольники)**: конкретные действия, выполняемые участниками.
    * **Шлюзы (ромбы)**: точки принятия решений (разветвления или слияния потоков).
* **Организационные элементы**:
    * **Пулы (Pools)**: участники процесса (например, разные организации).
    * **Дорожки (Lanes)**: роли или отделы внутри одного пула.
* **Связующие объекты**: потоки операций (сплошные стрелки) и потоки сообщений (пунктирные стрелки между пулами).
---
### 40. Применение BPMN для моделирования бизнес-процессов в организациях

BPMN используется организациями для повышения прозрачности и эффективности работы:
* **Визуализация**: создание наглядной карты процессов «как есть» (As-Is).
* **Автоматизация**: модели BPMN могут быть напрямую исполнены специализированными движками (BPMS), что превращает схему в работающее приложение.
* **Анализ**: поиск «узких мест», дублирующих функций и лишних этапов, которые замедляют работу.
* **Стандартизация**: создание единой базы знаний для обучения сотрудников и соблюдения регламентов.
---
### 41. ARIS нотация: элементы и цвета eEPC. Применение ARIS для оптимизации

**ARIS eEPC (extended Event-driven Process Chain)** ориентирована на описание событийной логики бизнес-процессов.

* **Основные элементы и их цвета**:
    * **События (Гексагоны, розовый)**: состояния, которые инициируют или завершают функции.
    * **Функции (Прямоугольники, зеленый)**: действия, выполняемые в рамках процесса.
    * **Организационные единицы (Овалы, желтый)**: кто выполняет работу.
    * **Документы/Данные (Прямоугольники, серый/белый)**: информация, используемая или создаваемая функцией.
    * **Логические операторы (Круги с символами AND, OR, XOR)**: разветвление логики.
* **Оптимизация**: ARIS позволяет строить комплексную модель организации (от стратегии до ИТ-систем), выявлять неэффективные связи между подразделениями и моделировать состояние «как должно быть» (To-Be) для внедрения изменений.
---
### 42. Управление версиями исходного кода: Git. Основные операции и ветвления

**Git** - это распределенная система контроля версий, предназначенная для отслеживания изменений в исходном коде и совместной работы программистов. Она позволяет сохранять историю разработки, возвращаться к предыдущим версиям и работать над разными частями проекта параллельно.

#### Основные операции
Работа в Git строится на нескольких базовых командах, которые обеспечивают полный цикл управления кодом:
* **Инициализация (git init)**: создание нового репозитория в папке проекта.
* **Индексация (git add)**: выбор измененных файлов, которые должны войти в следующий «снимок» (коммит).
* **Фиксация (git commit)**: сохранение изменений в локальной базе данных. Каждый коммит имеет уникальный хеш и комментарий разработчика.
* **Синхронизация (git push / git pull)**: отправка своих изменений на сервер и получение обновлений от коллег.

#### Механизм ветвления
Ветвление - одна из самых мощных функций Git, позволяющая отклоняться от основной линии разработки:
* **Создание веток (git branch)**: позволяет разработчику создать изолированное пространство для работы над конкретной задачей (новым модулем или исправлением багов), не рискуя сломать стабильный код в главной ветке (обычно `main` или `master`).
* **Переключение (git checkout / switch)**: возможность мгновенно переходить между разными состояниями проекта.
* **Слияние (git merge)**: процесс переноса изменений из рабочей ветки в основную после того, как код прошел проверку.

#### Разрешение конфликтов
При интеграции модулей, если двое разработчиков изменили одну и ту же строку в разных ветках, возникает конфликт. В этом случае Git останавливает слияние и требует от программиста вручную выбрать верный вариант кода, после чего фиксируется итоговый результат.

Использование Git является стандартом в индустрии, так как обеспечивает прозрачность разработки, безопасность хранения кода и упрощает процесс интеграции программных модулей.

### 43. Модели жизненного цикла ПО
**Жизненный цикл** - схема упорядочивания работ по проектированию и разработке. Стандарт **ISO 12207** делит процессы на основные (разработка, эксплуатация), поддержки (QA, верификация) и организационные. Модели (Waterfall, Agile и др.) определяют конкретную логику выполнения этих процессов.

Модели смотри в вопросе 16

### 44. Понятие DevOps. Контейниризация, CI/CD
**DevOps** – это философия или культура (и даже методология), которая создает единую среду работы внутри команды разработки и поддержки. Она включает процессы и специальные технические решения.
**Главная идея DevOps:** сближение сфер разработки и системного администрирования.

**Определение с Википедии:** **DevOps** - методология автоматизации технологических процессов сборки, настройки и развёртывания программного обеспечения. Методология предполагает активное взаимодействие специалистов по разработке со специалистами по информационно-технологическому обслуживанию и взаимную интеграцию их технологических процессов друг в друга для обеспечения высокого качества программного продукта. Предназначена для эффективной организации создания и обновления программных продуктов и услуг. Основана на идее тесной взаимозависимости создания продукта и эксплуатации программного обеспечения, которая прививается команде как культура создания продукта.

**Контейнеризация** - это технология упаковки приложения и всех его зависимостей (библиотек, файлов) в изолированное, переносимое окружение - контейнер, который работает одинаково в любой среде, абстрагируясь от операционной системы хоста, что упрощает разработку, развертывание и масштабирование ПО, позволяя запускать множество легких контейнеров на одном ядре ОС, в отличие от виртуальных машин, которые требуют полноценных ОС.

**Примеры программных решений для контейнеризации:**
- Docker
- LXC
- Podman

**CI/CD (Непрерывная интеграция (Continuous Integration, CI) и непрерывная поставка (Continuous Delivery, CD))** - является DevOps, а так же Agile-практикой. Это способ разработки, в котором тестирование и развёртывание кода происходит автоматически. **Основная цель** - ускорить выпуск обновлений и повысить качество ПО за счёт регулярного тестирования.

**Continuous integration (CI, непрерывная интеграция)** - автоматическая интеграция кода в репозиторий проекта. Цель CI — упростить объединение кода от разных разработчиков и быстро выявлять ошибки. Когда программист отправляет код в репозиторий, система запускает тесты. Если в проекте найдутся ошибки, то разработчику придётся забрать код на доработку.

**Continuous delivery (CD, непрерывная доставка)** - это автоматическая подготовка кода к выпуску. При каждом изменении кода CD-система автоматически тестирует работоспособность, собирает нужные файлы и разворачивает приложение в тестовой среде. Когда менеджер проекта принимает решение о выпуске новой версии, он активирует публикацию одним нажатием - и подготовленный код разворачивается на рабочем сервере.

**Continuous deployment (CD, непрерывное развёртывание)** - автоматическая доставка кода пользователям без участия разработчиков. Каждое изменение в коде, прошедшее тесты, сразу уходит на основной сервер.

### 45. Организация работы в системе контроля версий: ветвление, слияние, фиксация изменений
Работа в современных системах контроля версий (например, Git) строится на управлении изменениями через механизмы фиксации, ветвления и последующего объединения кода.

* **Фиксация изменений (Commit)**:
    * Представляет собой создание «снимка» (snapshot) текущего состояния файлов проекта в репозитории.
    * Каждый коммит сопровождается уникальным идентификатором и авторским описанием, что позволяет отслеживать историю изменений и при необходимости возвращаться к предыдущим версиям.
    * Рекомендуется делать атомарные коммиты, которые содержат логически завершенное изменение (например, исправление одной ошибки или реализацию одной функции).

* **Ветвление (Branching)**:
    * Позволяет изолировать процесс разработки новых функций или исправления ошибок от основной стабильной версии кода.
    * Разработчики могут создавать неограниченное количество веток (например, `feature`, `bugfix`), что дает возможность нескольким специалистам работать над разными задачами одновременно, не мешая друг другу.
    * Основная ветка (обычно `main` или `master`) всегда должна содержать работоспособный и протестированный код.

* **Слияние (Merging)**:
    * Процесс объединения изменений из одной ветки в другую (чаще всего из тематической ветки в основную).
    * В ходе слияния система автоматически сопоставляет изменения; если одни и те же строки кода были изменены в обеих ветках по-разному, возникает конфликт слияния, который разработчик должен разрешить вручную.
    * После успешного слияния и проверки корректности интеграции модулей временная ветка обычно удаляется.

Этот цикл (создание ветки → фиксация изменений → слияние) является стандартом профессиональной разработки и обеспечивает целостность программного продукта.

### 46. Внешнее проектирование: разработка внешней спецификации, описание интерфейсов и взаимодействий

Внешнее проектирование является этапом жизненного цикла разработки, на котором система рассматривается как «черный ящик». Основное внимание уделяется не внутренней реализации, а тому, как продукт будет взаимодействовать с окружающей средой.

* **Разработка внешней спецификации**:
    * Это документ, который описывает функциональность системы с точки зрения конечного пользователя или заказчика.
    * В спецификации фиксируются логика работы функций, входные и выходные данные, а также ограничения (производительность, надежность, требования к аппаратному обеспечению).
    * Цель - создать четкое описание того, «что» должна делать система, без уточнения того, «как» это реализовано программно.

* **Описание интерфейсов**:
    * **Пользовательские интерфейсы (UI)**: проектирование внешнего вида экранов, форм и элементов управления, с которыми будет взаимодействовать человек.
    * **Программные интерфейсы (API)**: описание набора правил и протоколов, через которые другие программы могут обращаться к функциям данной системы.
    * **Аппаратные интерфейсы**: описание способов сопряжения ПО с техническими устройствами.

* **Описание взаимодействий**:
    * Определяется протокол общения системы с внешними сущностями: базами данных, сторонними сервисами или пользователями.
    * На этом этапе часто используются диаграммы UML (например, диаграммы последовательностей или вариантов использования), чтобы визуализировать порядок обмена сообщениями и реакцию системы на внешние события.

Результатом внешнего проектирования является полное представление о поведении системы, которое служит основой для последующего внутреннего проектирования и написания кода.

---
### 47. Внутреннее проектирование: создание схем, диаграмм UML, DFD, IDEF0 и других моделей
Проектирование ПО (Software Design) — это процесс определения архитектуры, состава компонентов и их интерфейсов
- Технический проект (ТП): На этой стадии согласно ГОСТ 19.106-78 разрабатывается структура ПО: выделяются все компоненты по функциональным признакам и определяются их спецификации
- Инструменты моделирования: Для описания элементов используются нотации проектирования
    - Структурные нотации (напр., UML, ERD): отображают интерфейсы и взаимосвязи
    - Поведенческие нотации (напр., DFD — диаграммы потоков данных, диаграммы состояний): представляют динамику работы системы
- UML может использоваться как эскиз (визуализация), как детальная модель или как исполняемый проект (MDA), из которого генерируется код
---
### 48. Разработка модулей проекта: принципы модульного программирования, проектирование функций и классов
Разработка модулей является частью процесса конструирования ПО, который заключается в создании системы из блоков, функций и классов
- Модульность: Базовая концепция, предполагающая выделение автономных компонентов системы
- Декомпозиция: Процедура разделения подсистем на составляющие их модули для создания иерархически организованной системы
- Основные принципы конструирования:
    - Снижение сложности: Акцент на читаемости кода (принцип KISS)
    - Инкапсуляция: Отделение реализации модуля от его внешнего представления
    - Ожидание изменений: Проектирование модулей с помощью UML-диаграмм для возможности оперативной корректировки кода
---
### 49. Интеграция модулей в программное обеспечение: способы объединения, проверка совместимости и корректности
**Интеграция** — это процесс объединения компонентов в единую систему, входящий в основной процесс «Разработка» стандарта ISO 12207
- Проверка корректности и совместимости: Состоит в определении степени соответствия модулей исходным требованиям ТЗ и спецификациям
- Оценивается качество совместной работы компонентов и баз данных на различных платформах
- Методы интеграции:
    - Непрерывная интеграция (Continuous Integration): Частая (несколько раз в день) автоматизированная сборка продукта для раннего выявления проблем взаимодействия
    - Интеграционное тестирование: Проверка взаимодействия между модулями после завершения их модульной отладки
    - Использование стандартов: Применение интерфейсных языков и стандартов взаимодействия (напр., COM, CORBA) для обеспечения совместимости
---
### 50. Модификация модулей проекта: причины изменений, методы обновления и оптимизации кода
Модификация относится к области сопровождения ПО — действий по внесению изменений при выявлении ошибок или для улучшения характеристик
- Причины изменений (категории сопровождения):
    - Корректировка: устранение ошибок
    - Адаптация: настройка под новую среду эксплуатации
    - Предотвращение: устранение скрытых дефектов до сбоя
    - Улучшение: повышение производительности
- Методы обновления и оптимизации:
    - Рефакторинг: реорганизация кода для улучшения структуры без изменения его функциональности
    - Реинженерия: усовершенствование ПО через реструктуризацию и настройку под новую среду
    - Реверсная инженерия: анализ кода для выделения компонентов и их связей при подготовке к перепрограммированию под новую платформу
